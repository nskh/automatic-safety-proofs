
Directory /Users/sdane/desktop/PVS/pvslib in PVS_LIBRARY_PATH does not exist
Defining METIT. 
Defining SIMPLIFY-NTH1__. 
Defining SIMPLIFY-NTH1__$. 
Defining SIMPLIFY-NTH. 
Defining SIMPLIFY-NTH$. Loading prelude library NASALib/pvsio_utils (/Users/sdane/Desktop/PVS/nasalib/pvsio_utils/)

*** 
*** Processing debug_proof.pvs (14:55:55 9/10/2025)
*** Generated by proveit 7.1.0 (Nov 05, 2020)
*** Trusted Oracles
***   METIT: Try (help METIT)
*** 
Context changed to /Users/sdane/Desktop/automatic-safety-proofs/
Parsing debug_proof
debug_proof parsed in 0.00 seconds
Typechecking debug_proof
Parsing derivative_props
derivative_props parsed in 0.01 seconds
derivative_props is already parsed
Typechecking derivative_props
Parsing deriv_domain_def
deriv_domain_def parsed in 0.00 seconds
deriv_domain_def is already parsed
Typechecking deriv_domain_def
deriv_domain_def typechecked in 0.02s: No TCCs generated
Parsing derivatives_alt
derivatives_alt parsed in 0.00 seconds
derivatives_alt is already parsed
Typechecking derivatives_alt
Parsing derivatives
derivatives parsed in 0.00 seconds
derivatives is already parsed
Typechecking derivatives
Parsing derivatives_def
derivatives_def parsed in 0.00 seconds
derivatives_def is already parsed
Typechecking derivatives_def
Parsing lim_of_functions
lim_of_functions parsed in 0.00 seconds
lim_of_functions is already parsed
Typechecking lim_of_functions
Parsing convergence_functions
convergence_functions parsed in 0.00 seconds
convergence_functions is already parsed
Typechecking convergence_functions
Restored theory from /Users/sdane/Desktop/PVS/nasalib/reals/pvsbin/real_fun_ops.bin in 0.11s (load part took 0.00s)
Parsing epsilon_lemmas
epsilon_lemmas parsed in 0.00 seconds
epsilon_lemmas is already parsed
Typechecking epsilon_lemmas
Restored theory from /Users/sdane/Desktop/PVS/nasalib/reals/pvsbin/real_facts.bin in 0.02s (load part took 0.00s)
Restored theory from /Users/sdane/Desktop/PVS/nasalib/reals/pvsbin/root.bin in 0.02s (load part took 0.00s)
Restored theory from /Users/sdane/Desktop/PVS/nasalib/reals/pvsbin/sq.bin in 0.02s (load part took 0.00s)
Restored theory from /Users/sdane/Desktop/PVS/nasalib/reals/pvsbin/abs_lems.bin in 0.02s (load part took 0.00s)
epsilon_lemmas typechecked in 0.20s: 2 TCCs, 0 proved, 0 subsumed, 2 unproved
convergence_functions typechecked in 0.37s: No TCCs generated

 In declaration cv_abs:
  added conversion restrict[real, T, real]
             
  to abs, converting
     [real -> real]
  to [T -> real]

lim_of_functions typechecked in 0.48s: 10 TCCs, 0 proved, 0 subsumed, 10 unproved; 1 conversion
Parsing continuous_functions
continuous_functions parsed in 0.00 seconds
continuous_functions is already parsed
Typechecking continuous_functions

 In declaration continuous_on_def:
  added conversion extend[real, T, bool, FALSE]
             
  to E, converting
     [T -> bool]
  to [real -> bool]


 In declaration continuous_def2:
  added conversion restrict[real, T, boolean]
             
  to T_pred, converting
     [real -> boolean]
  to [T -> boolean]

continuous_functions typechecked in 0.06s: 11 TCCs, 0 proved, 0 subsumed, 11 unproved; 2 conversions; 1 warning
derivatives_def typechecked in 0.68s: 14 TCCs, 0 proved, 3 subsumed, 11 unproved

 LET/WHERE variable f at line 142, col 32 is given type
  [T -> real] from its value expression.


 LET/WHERE variable f at line 154, col 29 is given type
  [T -> real] from its value expression.

derivatives typechecked in 0.76s: 24 TCCs, 0 proved, 2 subsumed, 22 unproved; 1 warning; 2 msgs
Parsing continuous_functions_props
continuous_functions_props parsed in 0.00 seconds
continuous_functions_props is already parsed
Typechecking continuous_functions_props
Parsing continuity_interval
continuity_interval parsed in 0.00 seconds
continuity_interval is already parsed
Typechecking continuity_interval
Parsing continuity_props
continuity_props parsed in 0.00 seconds
continuity_props is already parsed
Typechecking continuity_props
Parsing top_sequences
top_sequences parsed in 0.00 seconds
top_sequences is already parsed
Typechecking top_sequences
Parsing convergence_ops
convergence_ops parsed in 0.00 seconds
convergence_ops is already parsed
Typechecking convergence_ops
Parsing convergence_sequences
convergence_sequences parsed in 0.00 seconds
convergence_sequences is already parsed
Typechecking convergence_sequences
Parsing sequence_props
sequence_props parsed in 0.00 seconds
sequence_props is already parsed
Typechecking sequence_props
Parsing real_fun_supinf
real_fun_supinf parsed in 0.00 seconds
real_fun_supinf is already parsed
Typechecking real_fun_supinf
Parsing real_fun_props
real_fun_props parsed in 0.00 seconds
real_fun_props is already parsed
Typechecking real_fun_props
Parsing real_fun_preds
real_fun_preds parsed in 0.00 seconds
real_fun_preds is already parsed
Typechecking real_fun_preds
real_fun_preds typechecked in 0.00s: No TCCs generated
real_fun_props typechecked in 0.01s: No TCCs generated
real_fun_supinf typechecked in 0.43s: 5 TCCs, 0 proved, 0 subsumed, 5 unproved
sequence_props typechecked in 0.46s: 1 TCC, 0 proved, 0 subsumed, 1 unproved
Parsing monotone_subsequence
monotone_subsequence parsed in 0.00 seconds
monotone_subsequence is already parsed
Typechecking monotone_subsequence
monotone_subsequence typechecked in 0.02s: 4 TCCs, 0 proved, 0 subsumed, 4 unproved
convergence_sequences typechecked in 0.56s: 3 TCCs, 0 proved, 0 subsumed, 3 unproved
convergence_ops typechecked in 0.64s: 14 TCCs, 0 proved, 1 subsumed, 13 unproved
top_sequences typechecked in 0.67s: No TCCs generated
continuity_props typechecked in 0.68s: No TCCs generated
continuity_interval typechecked in 0.71s: 14 TCCs, 0 proved, 5 subsumed, 9 unproved
continuous_functions_props typechecked in 0.74s: 1 TCC, 0 proved, 0 subsumed, 1 unproved
derivatives_alt typechecked in 1.569s: 2 TCCs, 0 proved, 0 subsumed, 2 unproved

 In declaration deriv_neg_neg:
  added conversion extend[real, T, bool, FALSE]
             
  to fullset[T], converting
     [T -> bool]
  to [real -> bool]


 In declaration deriv_neg_neg:
  added conversion extend[real, T, bool, FALSE]
             
  to fullset[T], converting
     [T -> bool]
  to [real -> bool]


 In declaration neg_spot:
  added conversion extend[real, T, bool, FALSE]
             
  to fullset[T], converting
     [T -> bool]
  to [real -> bool]


 In declaration deriv_neg_root:
  added conversion extend[real, T, bool, FALSE]
             
  to fullset[T], converting
     [T -> bool]
  to [real -> bool]


 In declaration deriv_neg_root:
  added conversion extend[real, T, bool, FALSE]
             
  to fullset[T], converting
     [T -> bool]
  to [real -> bool]

derivative_props typechecked in 1.733s: 15 TCCs, 0 proved, 7 subsumed, 8 unproved; 5 conversions
Created directory /Users/sdane/Desktop/PVS/nasalib/analysis/pvsbin
Parsing deriv_domain
deriv_domain parsed in 0.00 seconds
deriv_domain is already parsed
Typechecking deriv_domain
Restored theory from /Users/sdane/Desktop/PVS/nasalib/reals/pvsbin/intervals_real.bin in 0.02s (load part took 0.00s)
deriv_domain typechecked in 0.04s: No TCCs generated

 In declaration mvt_gen_ge:
  added conversion restrict[real, (D), real]
             
  to f, converting
     [real -> real]
  to [(D) -> real]


 In declaration mvt_gen_ge:
  added conversion restrict[real, (D), real]
             
  to f, converting
     [real -> real]
  to [(D) -> real]


 In declaration mvt_gen_le:
  added conversion restrict[real, (D), real]
             
  to f, converting
     [real -> real]
  to [(D) -> real]


 In declaration mvt_gen_le:
  added conversion restrict[real, (D), real]
             
  to f, converting
     [real -> real]
  to [(D) -> real]


 In declaration mvt_gen_ge_lo:
  added conversion restrict[real, (left_open(C)), real]
             
  to f, converting
     [real -> real]
  to [(left_open(C)) -> real]


 In declaration mvt_gen_ge_lo:
  added conversion restrict[real, (left_open(C)), real]
             
  to f, converting
     [real -> real]
  to [(left_open(C)) -> real]


 In declaration mvt_gen_le_lo:
  added conversion restrict[real, (left_open(C)), real]
             
  to f, converting
     [real -> real]
  to [(left_open(C)) -> real]


 In declaration mvt_gen_le_lo:
  added conversion restrict[real, (left_open(C)), real]
             
  to f, converting
     [real -> real]
  to [(left_open(C)) -> real]


 In declaration mvt_gen_ge_ro:
  added conversion restrict[real, (right_open(C)), real]
             
  to f, converting
     [real -> real]
  to [(right_open(C)) -> real]


 In declaration mvt_gen_ge_ro:
  added conversion restrict[real, (right_open(C)), real]
             
  to f, converting
     [real -> real]
  to [(right_open(C)) -> real]


 In declaration mvt_gen_le_ro:
  added conversion restrict[real, (right_open(C)), real]
             
  to f, converting
     [real -> real]
  to [(right_open(C)) -> real]


 In declaration mvt_gen_le_ro:
  added conversion restrict[real, (right_open(C)), real]
             
  to f, converting
     [real -> real]
  to [(right_open(C)) -> real]


 In declaration mvt_gen_ge_ci:
  added conversion restrict[real, (ci(d1, d2)), real]
             
  to f, converting
     [real -> real]
  to [(ci(d1, d2)) -> real]


 In declaration mvt_gen_ge_ci:
  added conversion restrict[real, (ci(d1, d2)), real]
             
  to f, converting
     [real -> real]
  to [(ci(d1, d2)) -> real]


 In declaration mvt_gen_le_ci:
  added conversion restrict[real, (ci(d1, d2)), real]
             
  to f, converting
     [real -> real]
  to [(ci(d1, d2)) -> real]


 In declaration mvt_gen_le_ci:
  added conversion restrict[real, (ci(d1, d2)), real]
             
  to f, converting
     [real -> real]
  to [(ci(d1, d2)) -> real]


 LET/WHERE variable f at line 244, col 12 is given type
  [real -> real] from its value expression.


 LET/WHERE variable g at line 276, col 8 is given type
  [real -> real] from its value expression.

Orphan file /Users/sdane/Desktop/automatic-safety-proofs/orphaned-proofs.prf returned 17 proofs, found 17 bad ones
Added 5 proofs from file debug_proof.prf, theory active_corner_certificate to orphaned-proofs.prf
active_corner_certificate typechecked in 4.092s: 16 TCCs, 0 proved, 6 subsumed, 10 unproved; 16 conversions; 2 msgs
Created directory /Users/sdane/Desktop/automatic-safety-proofs/pvsbin
Context file /Users/sdane/Desktop/automatic-safety-proofs/.pvscontext written

Installing inlined proof scripts into theory active_corner_certificate.
Proof script left_open_connected was installed
Proof script left_open_noe was installed
Proof script left_open_dd was installed
Proof script right_open_connected was installed
Proof script right_open_noe was installed
Proof script right_open_dd was installed
Proof script ci_noe was installed
Proof script ci_connected was installed
Proof script ci_dd was installed
Proof script mvt_gen_ge was installed
Proof script mvt_gen_le was installed
Proof script mvt_gen_ge_lo was installed
Proof script mvt_gen_le_lo was installed
Proof script mvt_gen_ge_ro was installed
Proof script mvt_gen_le_ro was installed
Proof script mvt_gen_ge_ci was installed
Proof script mvt_gen_le_ci was installed
Proof script mvt_gen_ge_real was installed
Proof script mvt_gen_le_real was installed
Proof script ge_real_case_0 was installed
Proof script full_domain_soundness_lemma was installed
Proof script mvt_gen_ge_TCC1 was installed
Proof script mvt_gen_ge_TCC2 was installed
Proof script mvt_gen_ge_lo_TCC1 was installed
Proof script mvt_gen_ge_lo_TCC2 was installed
Proof script mvt_gen_ge_ro_TCC1 was installed
Proof script mvt_gen_ge_ro_TCC2 was installed
Proof script mvt_gen_ge_ci_TCC1 was installed
Proof script mvt_gen_ge_ci_TCC2 was installed
Proof script mvt_gen_ge_real_TCC1 was installed
Proof script mvt_gen_ge_real_TCC2 was installed
Proof script mvt_gen_ge_TCC1 was installed
Proof script mvt_gen_ge_lo_TCC1 was installed
Proof script mvt_gen_ge_lo_TCC2 was installed
Proof script mvt_gen_ge_ro_TCC1 was installed
Proof script mvt_gen_ge_ro_TCC2 was installed
Proof script mvt_gen_ge_ci_TCC1 was installed
Proof script mvt_gen_ge_ci_TCC2 was installed
"full_domain_soundness_lemma_helper_TCC*" does not match any formula
Defining DERIVABLE__. 
Defining DERIVABLE__$. 
Defining DERIV-DOMAIN__. 
Defining DERIV-DOMAIN__$. 
Defining DERIVABLE. 
Defining DERIVABLE$. 
Defining DIFFERENTIABLE. 
Defining DERIV__. 
Defining DERIV__$. 
; file: //Users/sdane/Desktop/PVS/nasalib/analysis//pvs-strategies
; in: DEFSTEP DERIV
;     (PVS::EXTRA-GET-FNUM PVS::FN!)
; 
; caught WARNING:
;   undefined variable: PVS::FN!

;     (PVS::EXTRA-GET-FORMULA PVS::FN!)
; 
; caught WARNING:
;   undefined variable: PVS::FN!
; 
; compilation unit finished
;   Undefined variable:
;     FN!
;   caught 2 WARNING conditions

Defining DERIV. 
Defining DERIV$. 
Defining DERIVATIVE. 
Defining SQRT-REW. 
Defining SQRT-REW$. 
Defining SQRT-REW-OFF. 
Defining SQRT-REW-OFF$. 
Proving theory active_corner_certificate
Rerunning proof of active_corner_certificate.left_open_connected
Installing rewrite rule sets.singleton_rew (all instances)
Installing rewrite rule analysis@lim_of_functions.adherence_fullset (all instances)
Installing rewrite rule reals@sq.sq_abs_neg
Installing rewrite rule reals@sq.sq_abs
Installing rewrite rule reals@sq.sq_1
Installing rewrite rule reals@sq.sq_0
Installing rewrite rule reals@abs_lems.abs_0
Installing rewrite rule reals@abs_lems.abs_nat
Installing rewrite rule sets.member (all instances)
Installing rewrite rule list_props.member (all instances)
left_open_connected :  

  |-------
{1}   FORALL (c: real): connected?[(left_open(c))]

Rerunning step: (THEN (SKEEP) (EXPAND "connected?") (SKEEP) (TYPEPRED "x" "y")
                 (EXPAND "left_open") (ASSERT))
Skolemizing and keeping names of the universal formula in (+ -),
this simplifies to: 
left_open_connected :  

  |-------
{1}   connected?[(left_open(c))]

Expanding the definition of connected?,
this simplifies to: 
left_open_connected :  

  |-------
{1}   FORALL (x: (left_open(c)), y: (left_open(c))), (z: real):
        x <= z AND z <= y IMPLIES left_open(c)(z)

Skolemizing and keeping names of the universal formula in (+ -),
this simplifies to: 
left_open_connected :  

{-1}  x <= z
{-2}  z <= y
  |-------
{1}   left_open(c)(z)

Adding type constraints for  x, y,
this simplifies to: 
left_open_connected :  

{-1}  left_open(c)(x)
{-2}  left_open(c)(y)
[-3]  x <= z
[-4]  z <= y
  |-------
[1]   left_open(c)(z)

Expanding the definition of left_open,
this simplifies to: 
left_open_connected :  

{-1}  c >= x
{-2}  c >= y
[-3]  x <= z
[-4]  z <= y
  |-------
{1}   c >= z

Simplifying, rewriting, and recording with decision procedures,
Q.E.D.


Run time  = 0.05 secs.
Real time = 0.05 secs.

active_corner_certificate.left_open_connected proved in 0.05 real, 0.05 cpu seconds
Rerunning proof of active_corner_certificate.left_open_noe
Installing rewrite rule sets.singleton_rew (all instances)
Installing rewrite rule analysis@lim_of_functions.adherence_fullset (all instances)
Installing rewrite rule reals@sq.sq_abs_neg
Installing rewrite rule reals@sq.sq_abs
Installing rewrite rule reals@sq.sq_1
Installing rewrite rule reals@sq.sq_0
Installing rewrite rule reals@abs_lems.abs_0
Installing rewrite rule reals@abs_lems.abs_nat
Installing rewrite rule sets.member (all instances)
Installing rewrite rule list_props.member (all instances)
left_open_noe :  

  |-------
{1}   FORALL (c: real): not_one_element?[(left_open(c))]

Rerunning step: (THEN (SKEEP) (EXPAND "not_one_element?") (SKEEP)
                 (SPREAD (INST 1 "x-1")
                  ((ASSERT)
                   (THEN (TYPEPRED "x") (EXPAND "left_open") (ASSERT)))))
Skolemizing and keeping names of the universal formula in (+ -),
this simplifies to: 
left_open_noe :  

  |-------
{1}   not_one_element?[(left_open(c))]

Expanding the definition of not_one_element?,
this simplifies to: 
left_open_noe :  

  |-------
{1}   (FORALL (x: (left_open(c))): EXISTS (y: (left_open(c))): x /= y)

Skolemizing and keeping names of the universal formula in (+ -),
this simplifies to: 
left_open_noe :  

  |-------
{1}   EXISTS (y: (left_open(c))): x /= y

Instantiating the top quantifier in 1 with the terms: 
 x-1,
this yields  2 subgoals: 
left_open_noe.1 :  

  |-------
{1}   x /= x - 1

Simplifying, rewriting, and recording with decision procedures,

This completes the proof of left_open_noe.1.

left_open_noe.2 (TCC):   

  |-------
{1}   left_open(c)(x - 1)

Adding type constraints for  x,
this simplifies to: 
left_open_noe.2 :  

{-1}  left_open(c)(x)
  |-------
[1]   left_open(c)(x - 1)

Expanding the definition of left_open,
this simplifies to: 
left_open_noe.2 :  

{-1}  c >= x
  |-------
{1}   c >= x - 1

Simplifying, rewriting, and recording with decision procedures,

This completes the proof of left_open_noe.2.

Q.E.D.


Run time  = 0.03 secs.
Real time = 0.03 secs.

active_corner_certificate.left_open_noe proved in 0.03 real, 0.03 cpu seconds
Rerunning proof of active_corner_certificate.left_open_dd
Installing rewrite rule sets.singleton_rew (all instances)
Installing rewrite rule analysis@lim_of_functions.adherence_fullset (all instances)
Installing rewrite rule reals@sq.sq_abs_neg
Installing rewrite rule reals@sq.sq_abs
Installing rewrite rule reals@sq.sq_1
Installing rewrite rule reals@sq.sq_0
Installing rewrite rule reals@abs_lems.abs_0
Installing rewrite rule reals@abs_lems.abs_nat
Installing rewrite rule sets.member (all instances)
Installing rewrite rule list_props.member (all instances)
left_open_dd :  

  |-------
{1}   FORALL (c: real): deriv_domain?[(left_open(c))]

Rerunning step: (THEN (SKEEP) (LEMMA "connected_deriv_domain[(left_open(c))]")
                 (ASSERT) (HIDE 2) (LEMMA " left_open_connected")
                 (LEMMA " left_open_noe") (INST?) (INST?) (ASSERT))
Skolemizing and keeping names of the universal formula in (+ -),
this simplifies to: 
left_open_dd :  

  |-------
{1}   deriv_domain?[(left_open(c))]

Applying connected_deriv_domain[(left_open(c))] 
this simplifies to: 
left_open_dd :  

{-1}  connected? AND not_one_element? IMPLIES deriv_domain?
  |-------
[1]   deriv_domain?[(left_open(c))]

Simplifying, rewriting, and recording with decision procedures,
this simplifies to: 
left_open_dd :  

  |-------
{1}   connected? AND not_one_element?
[2]   deriv_domain?[(left_open(c))]

Hiding formulas:  2,
this simplifies to: 
left_open_dd :  

  |-------
[1]   connected? AND not_one_element?

Applying left_open_connected 
this simplifies to: 
left_open_dd :  

{-1}  FORALL (c: real): connected?[(left_open(c))]
  |-------
[1]   connected? AND not_one_element?

Applying left_open_noe 
this simplifies to: 
left_open_dd :  

{-1}  FORALL (c: real): not_one_element?[(left_open(c))]
[-2]  FORALL (c: real): connected?[(left_open(c))]
  |-------
[1]   connected? AND not_one_element?

Found substitution:
c: real gets c,
Using template: c
Instantiating quantified variables,
this simplifies to: 
left_open_dd :  

{-1}  not_one_element?[(left_open(c))]
[-2]  FORALL (c: real): connected?[(left_open(c))]
  |-------
[1]   connected? AND not_one_element?

Found substitution:
c: real gets c,
Using template: c
Instantiating quantified variables,
this simplifies to: 
left_open_dd :  

[-1]  not_one_element?[(left_open(c))]
{-2}  connected?[(left_open(c))]
  |-------
[1]   connected? AND not_one_element?

Simplifying, rewriting, and recording with decision procedures,
Q.E.D.


Run time  = 0.02 secs.
Real time = 0.02 secs.

active_corner_certificate.left_open_dd proved in 0.02 real, 0.02 cpu seconds
Rerunning proof of active_corner_certificate.right_open_connected
Installing rewrite rule sets.singleton_rew (all instances)
Installing rewrite rule analysis@lim_of_functions.adherence_fullset (all instances)
Installing rewrite rule reals@sq.sq_abs_neg
Installing rewrite rule reals@sq.sq_abs
Installing rewrite rule reals@sq.sq_1
Installing rewrite rule reals@sq.sq_0
Installing rewrite rule reals@abs_lems.abs_0
Installing rewrite rule reals@abs_lems.abs_nat
Installing rewrite rule sets.member (all instances)
Installing rewrite rule list_props.member (all instances)
right_open_connected :  

  |-------
{1}   FORALL (c: real): connected?[(right_open(c))]

Rerunning step: (THEN (SKEEP) (EXPAND "connected?") (SKEEP) (TYPEPRED "x" "y")
                 (EXPAND "right_open") (ASSERT))
Skolemizing and keeping names of the universal formula in (+ -),
this simplifies to: 
right_open_connected :  

  |-------
{1}   connected?[(right_open(c))]

Expanding the definition of connected?,
this simplifies to: 
right_open_connected :  

  |-------
{1}   FORALL (x: (right_open(c)), y: (right_open(c))), (z: real):
        x <= z AND z <= y IMPLIES right_open(c)(z)

Skolemizing and keeping names of the universal formula in (+ -),
this simplifies to: 
right_open_connected :  

{-1}  x <= z
{-2}  z <= y
  |-------
{1}   right_open(c)(z)

Adding type constraints for  x, y,
this simplifies to: 
right_open_connected :  

{-1}  right_open(c)(x)
{-2}  right_open(c)(y)
[-3]  x <= z
[-4]  z <= y
  |-------
[1]   right_open(c)(z)

Expanding the definition of right_open,
this simplifies to: 
right_open_connected :  

{-1}  c <= x
{-2}  c <= y
[-3]  x <= z
[-4]  z <= y
  |-------
{1}   c <= z

Simplifying, rewriting, and recording with decision procedures,
Q.E.D.


Run time  = 0.03 secs.
Real time = 0.03 secs.

active_corner_certificate.right_open_connected proved in 0.03 real, 0.03 cpu seconds
Rerunning proof of active_corner_certificate.right_open_noe
Installing rewrite rule sets.singleton_rew (all instances)
Installing rewrite rule analysis@lim_of_functions.adherence_fullset (all instances)
Installing rewrite rule reals@sq.sq_abs_neg
Installing rewrite rule reals@sq.sq_abs
Installing rewrite rule reals@sq.sq_1
Installing rewrite rule reals@sq.sq_0
Installing rewrite rule reals@abs_lems.abs_0
Installing rewrite rule reals@abs_lems.abs_nat
Installing rewrite rule sets.member (all instances)
Installing rewrite rule list_props.member (all instances)
right_open_noe :  

  |-------
{1}   FORALL (c: real): not_one_element?[(right_open(c))]

Rerunning step: (THEN (SKEEP) (EXPAND "not_one_element?") (SKEEP)
                 (SPREAD (INST 1 "x+1")
                  ((ASSERT)
                   (THEN (TYPEPRED "x") (ASSERT) (EXPAND "right_open")
                    (ASSERT)))))
Skolemizing and keeping names of the universal formula in (+ -),
this simplifies to: 
right_open_noe :  

  |-------
{1}   not_one_element?[(right_open(c))]

Expanding the definition of not_one_element?,
this simplifies to: 
right_open_noe :  

  |-------
{1}   (FORALL (x: (right_open(c))): EXISTS (y: (right_open(c))): x /= y)

Skolemizing and keeping names of the universal formula in (+ -),
this simplifies to: 
right_open_noe :  

  |-------
{1}   EXISTS (y: (right_open(c))): x /= y

Instantiating the top quantifier in 1 with the terms: 
 x+1,
this yields  2 subgoals: 
right_open_noe.1 :  

  |-------
{1}   x /= x + 1

Simplifying, rewriting, and recording with decision procedures,

This completes the proof of right_open_noe.1.

right_open_noe.2 (TCC):   

  |-------
{1}   right_open(c)(1 + x)

Adding type constraints for  x,
this simplifies to: 
right_open_noe.2 :  

{-1}  right_open(c)(x)
  |-------
[1]   right_open(c)(1 + x)

Simplifying, rewriting, and recording with decision procedures,
this simplifies to: 
right_open_noe.2 :  

[-1]  right_open(c)(x)
  |-------
[1]   right_open(c)(1 + x)

Expanding the definition of right_open,
this simplifies to: 
right_open_noe.2 :  

{-1}  c <= x
  |-------
{1}   c <= 1 + x

Simplifying, rewriting, and recording with decision procedures,

This completes the proof of right_open_noe.2.

Q.E.D.


Run time  = 0.03 secs.
Real time = 0.03 secs.

active_corner_certificate.right_open_noe proved in 0.03 real, 0.03 cpu seconds
Rerunning proof of active_corner_certificate.right_open_dd
Installing rewrite rule sets.singleton_rew (all instances)
Installing rewrite rule analysis@lim_of_functions.adherence_fullset (all instances)
Installing rewrite rule reals@sq.sq_abs_neg
Installing rewrite rule reals@sq.sq_abs
Installing rewrite rule reals@sq.sq_1
Installing rewrite rule reals@sq.sq_0
Installing rewrite rule reals@abs_lems.abs_0
Installing rewrite rule reals@abs_lems.abs_nat
Installing rewrite rule sets.member (all instances)
Installing rewrite rule list_props.member (all instances)
right_open_dd :  

  |-------
{1}   FORALL (c: real): deriv_domain?[(right_open(c))]

Rerunning step: (THEN (SKEEP) (LEMMA "connected_deriv_domain[(right_open(c))]")
                 (ASSERT) (HIDE 2) (LEMMA " right_open_connected")
                 (LEMMA " right_open_noe") (INST?) (INST?) (ASSERT))
Skolemizing and keeping names of the universal formula in (+ -),
this simplifies to: 
right_open_dd :  

  |-------
{1}   deriv_domain?[(right_open(c))]

Applying connected_deriv_domain[(right_open(c))] 
this simplifies to: 
right_open_dd :  

{-1}  connected? AND not_one_element? IMPLIES deriv_domain?
  |-------
[1]   deriv_domain?[(right_open(c))]

Simplifying, rewriting, and recording with decision procedures,
this simplifies to: 
right_open_dd :  

  |-------
{1}   connected? AND not_one_element?
[2]   deriv_domain?[(right_open(c))]

Hiding formulas:  2,
this simplifies to: 
right_open_dd :  

  |-------
[1]   connected? AND not_one_element?

Applying right_open_connected 
this simplifies to: 
right_open_dd :  

{-1}  FORALL (c: real): connected?[(right_open(c))]
  |-------
[1]   connected? AND not_one_element?

Applying right_open_noe 
this simplifies to: 
right_open_dd :  

{-1}  FORALL (c: real): not_one_element?[(right_open(c))]
[-2]  FORALL (c: real): connected?[(right_open(c))]
  |-------
[1]   connected? AND not_one_element?

Found substitution:
c: real gets c,
Using template: c
Instantiating quantified variables,
this simplifies to: 
right_open_dd :  

{-1}  not_one_element?[(right_open(c))]
[-2]  FORALL (c: real): connected?[(right_open(c))]
  |-------
[1]   connected? AND not_one_element?

Found substitution:
c: real gets c,
Using template: c
Instantiating quantified variables,
this simplifies to: 
right_open_dd :  

[-1]  not_one_element?[(right_open(c))]
{-2}  connected?[(right_open(c))]
  |-------
[1]   connected? AND not_one_element?

Simplifying, rewriting, and recording with decision procedures,
Q.E.D.


Run time  = 0.01 secs.
Real time = 0.01 secs.

active_corner_certificate.right_open_dd proved in 0.01 real, 0.01 cpu seconds
Rerunning proof of active_corner_certificate.ci_noe
Installing rewrite rule sets.singleton_rew (all instances)
Installing rewrite rule analysis@lim_of_functions.adherence_fullset (all instances)
Installing rewrite rule reals@sq.sq_abs_neg
Installing rewrite rule reals@sq.sq_abs
Installing rewrite rule reals@sq.sq_1
Installing rewrite rule reals@sq.sq_0
Installing rewrite rule reals@abs_lems.abs_0
Installing rewrite rule reals@abs_lems.abs_nat
Installing rewrite rule sets.member (all instances)
Installing rewrite rule list_props.member (all instances)
ci_noe :  

  |-------
{1}   FORALL (d1, d2: real): d1 /= d2 IMPLIES not_one_element?[(ci(d1, d2))]

Rerunning step: (THEN (SKEEP) (EXPAND "not_one_element?") (SKEEP)
                 (TYPEPRED "x")
                 (SPREAD (INST-CP 2 "d1")
                  ((SPREAD (INST 2 "d2")
                    ((ASSERT) (THEN (EXPAND "ci") (ASSERT))))
                   (THEN (EXPAND "ci") (ASSERT) (FLATTEN) (ASSERT)))))
Skolemizing and keeping names of the universal formula in (+ -),
this simplifies to: 
ci_noe :  

  |-------
{1}   d1 = d2
{2}   not_one_element?[(ci(d1, d2))]

Expanding the definition of not_one_element?,
this simplifies to: 
ci_noe :  

  |-------
[1]   d1 = d2
{2}   (FORALL (x: (ci(d1, d2))): EXISTS (y: (ci(d1, d2))): x /= y)

Skolemizing and keeping names of the universal formula in (+ -),
this simplifies to: 
ci_noe :  

  |-------
[1]   d1 = d2
{2}   EXISTS (y: (ci(d1, d2))): x /= y

Adding type constraints for  x,
this simplifies to: 
ci_noe :  

{-1}  ci(d1, d2)(x)
  |-------
[1]   d1 = d2
[2]   EXISTS (y: (ci(d1, d2))): x /= y

Instantiating (with copying) the top quantifier in 2 with the terms:
d1,
this yields  2 subgoals: 
ci_noe.1 :  

[-1]  ci(d1, d2)(x)
  |-------
[1]   d1 = d2
[2]   EXISTS (y: (ci(d1, d2))): x /= y
{3}   x /= d1

Instantiating the top quantifier in 2 with the terms: 
 d2,
this yields  2 subgoals: 
ci_noe.1.1 :  

[-1]  ci(d1, d2)(x)
  |-------
[1]   d1 = d2
{2}   x /= d2
[3]   x /= d1

Simplifying, rewriting, and recording with decision procedures,

This completes the proof of ci_noe.1.1.

ci_noe.1.2 (TCC):   

[-1]  ci(d1, d2)(x)
  |-------
{1}   ci(d1, d2)(d2)
[2]   d1 = d2
[3]   x /= d1

Expanding the definition of ci,
this simplifies to: 
ci_noe.1.2 :  

{-1}  (d1 <= x AND x <= d2)
  |-------
{1}   d1 <= d2
[2]   d1 = d2
[3]   x /= d1

Simplifying, rewriting, and recording with decision procedures,

This completes the proof of ci_noe.1.2.


This completes the proof of ci_noe.1.

ci_noe.2 (TCC):   

[-1]  ci(d1, d2)(x)
  |-------
{1}   ci(d1, d2)(d1)
[2]   d1 = d2

Expanding the definition of ci,
this simplifies to: 
ci_noe.2 :  

{-1}  (d1 <= x AND x <= d2)
  |-------
{1}   d1 <= d2
[2]   d1 = d2

Simplifying, rewriting, and recording with decision procedures,
this simplifies to: 
ci_noe.2 :  

[-1]  (d1 <= x AND x <= d2)
  |-------
[1]   d1 <= d2
[2]   d1 = d2

Applying disjunctive simplification to flatten sequent,
this simplifies to: 
ci_noe.2 :  

{-1}  d1 <= x
{-2}  x <= d2
  |-------
[1]   d1 <= d2
[2]   d1 = d2

Simplifying, rewriting, and recording with decision procedures,

This completes the proof of ci_noe.2.

Q.E.D.


Run time  = 0.03 secs.
Real time = 0.03 secs.

active_corner_certificate.ci_noe proved in 0.03 real, 0.03 cpu seconds
Rerunning proof of active_corner_certificate.ci_connected
Installing rewrite rule sets.singleton_rew (all instances)
Installing rewrite rule analysis@lim_of_functions.adherence_fullset (all instances)
Installing rewrite rule reals@sq.sq_abs_neg
Installing rewrite rule reals@sq.sq_abs
Installing rewrite rule reals@sq.sq_1
Installing rewrite rule reals@sq.sq_0
Installing rewrite rule reals@abs_lems.abs_0
Installing rewrite rule reals@abs_lems.abs_nat
Installing rewrite rule sets.member (all instances)
Installing rewrite rule list_props.member (all instances)
ci_connected :  

  |-------
{1}   FORALL (d1, d2: real): d1 /= d2 IMPLIES connected?[(ci(d1, d2))]

Rerunning step: (THEN (SKEEP) (EXPAND "connected?" 2) (SKEEP)
                 (TYPEPRED "x" "y" "z") (EXPAND "ci") (ASSERT) (FLATTEN)
                 (ASSERT))
Skolemizing and keeping names of the universal formula in (+ -),
this simplifies to: 
ci_connected :  

  |-------
{1}   d1 = d2
{2}   connected?[(ci(d1, d2))]

Expanding the definition of connected?,
this simplifies to: 
ci_connected :  

  |-------
[1]   d1 = d2
{2}   FORALL (x: (ci(d1, d2)), y: (ci(d1, d2))), (z: real):
        x <= z AND z <= y IMPLIES ci(d1, d2)(z)

Skolemizing and keeping names of the universal formula in (+ -),
this simplifies to: 
ci_connected :  

{-1}  x <= z
{-2}  z <= y
  |-------
[1]   d1 = d2
{2}   ci(d1, d2)(z)

Adding type constraints for  x, y, z,
this simplifies to: 
ci_connected :  

{-1}  ci(d1, d2)(x)
{-2}  ci(d1, d2)(y)
{-3}  real_pred(z)
[-4]  x <= z
[-5]  z <= y
  |-------
[1]   d1 = d2
[2]   ci(d1, d2)(z)

Expanding the definition of ci,
this simplifies to: 
ci_connected :  

{-1}  (d1 <= x AND x <= d2)
{-2}  (d1 <= y AND y <= d2)
[-3]  real_pred(z)
[-4]  x <= z
[-5]  z <= y
  |-------
[1]   d1 = d2
{2}   (d1 <= z AND z <= d2)

Simplifying, rewriting, and recording with decision procedures,
this simplifies to: 
ci_connected :  

[-1]  (d1 <= x AND x <= d2)
[-2]  (d1 <= y AND y <= d2)
[-3]  real_pred(z)
[-4]  x <= z
[-5]  z <= y
  |-------
[1]   d1 = d2
[2]   (d1 <= z AND z <= d2)

Applying disjunctive simplification to flatten sequent,
this simplifies to: 
ci_connected :  

{-1}  d1 <= x
{-2}  x <= d2
{-3}  d1 <= y
{-4}  y <= d2
[-5]  real_pred(z)
[-6]  x <= z
[-7]  z <= y
  |-------
[1]   d1 = d2
[2]   (d1 <= z AND z <= d2)

Simplifying, rewriting, and recording with decision procedures,
Q.E.D.


Run time  = 0.04 secs.
Real time = 0.04 secs.

active_corner_certificate.ci_connected proved in 0.04 real, 0.04 cpu seconds
Rerunning proof of active_corner_certificate.ci_dd
Installing rewrite rule sets.singleton_rew (all instances)
Installing rewrite rule analysis@lim_of_functions.adherence_fullset (all instances)
Installing rewrite rule reals@sq.sq_abs_neg
Installing rewrite rule reals@sq.sq_abs
Installing rewrite rule reals@sq.sq_1
Installing rewrite rule reals@sq.sq_0
Installing rewrite rule reals@abs_lems.abs_0
Installing rewrite rule reals@abs_lems.abs_nat
Installing rewrite rule sets.member (all instances)
Installing rewrite rule list_props.member (all instances)
ci_dd :  

  |-------
{1}   FORALL (d1, d2: real): d1 /= d2 IMPLIES deriv_domain?[(ci(d1, d2))]

Rerunning step: (THEN (SKEEP) (LEMMA "connected_deriv_domain[(ci(d1,d2))]")
                 (ASSERT) (HIDE 2) (LEMMA " ci_connected") (LEMMA " ci_noe")
                 (TYPEPRED "d1" "d2") (REVEAL +) (INST -3 "d1" "d2")
                 (INST -4 "d1" "d2") (ASSERT))
Skolemizing and keeping names of the universal formula in (+ -),
this simplifies to: 
ci_dd :  

  |-------
{1}   d1 = d2
{2}   deriv_domain?[(ci(d1, d2))]

Applying connected_deriv_domain[(ci(d1, d2))] 
this simplifies to: 
ci_dd :  

{-1}  connected? AND not_one_element? IMPLIES deriv_domain?
  |-------
[1]   d1 = d2
[2]   deriv_domain?[(ci(d1, d2))]

Simplifying, rewriting, and recording with decision procedures,
this simplifies to: 
ci_dd :  

  |-------
{1}   connected? AND not_one_element?
[2]   d1 = d2
[3]   deriv_domain?[(ci(d1, d2))]

Hiding formulas:  2,
this simplifies to: 
ci_dd :  

  |-------
[1]   connected? AND not_one_element?
[2]   deriv_domain?[(ci(d1, d2))]

Applying ci_connected 
this simplifies to: 
ci_dd :  

{-1}  FORALL (d1, d2: real): d1 /= d2 IMPLIES connected?[(ci(d1, d2))]
  |-------
[1]   connected? AND not_one_element?
[2]   deriv_domain?[(ci(d1, d2))]

Applying ci_noe 
this simplifies to: 
ci_dd :  

{-1}  FORALL (d1, d2: real): d1 /= d2 IMPLIES not_one_element?[(ci(d1, d2))]
[-2]  FORALL (d1, d2: real): d1 /= d2 IMPLIES connected?[(ci(d1, d2))]
  |-------
[1]   connected? AND not_one_element?
[2]   deriv_domain?[(ci(d1, d2))]

Adding type constraints for  d1, d2,
this simplifies to: 
ci_dd :  

{-1}  real_pred(d1)
{-2}  real_pred(d2)
[-3]  FORALL (d1, d2: real): d1 /= d2 IMPLIES not_one_element?[(ci(d1, d2))]
[-4]  FORALL (d1, d2: real): d1 /= d2 IMPLIES connected?[(ci(d1, d2))]
  |-------
[1]   connected? AND not_one_element?
[2]   deriv_domain?[(ci(d1, d2))]

Revealing hidden formulas,
this simplifies to: 
ci_dd :  

[-1]  real_pred(d1)
[-2]  real_pred(d2)
[-3]  FORALL (d1, d2: real): d1 /= d2 IMPLIES not_one_element?[(ci(d1, d2))]
[-4]  FORALL (d1, d2: real): d1 /= d2 IMPLIES connected?[(ci(d1, d2))]
  |-------
{1}   d1 = d2
[2]   connected? AND not_one_element?
[3]   deriv_domain?[(ci(d1, d2))]

Instantiating the top quantifier in -3 with the terms: 
 d1, d2,
this simplifies to: 
ci_dd :  

[-1]  real_pred(d1)
[-2]  real_pred(d2)
{-3}  d1 /= d2 IMPLIES not_one_element?[(ci(d1, d2))]
[-4]  FORALL (d1, d2: real): d1 /= d2 IMPLIES connected?[(ci(d1, d2))]
  |-------
[1]   d1 = d2
[2]   connected? AND not_one_element?
[3]   deriv_domain?[(ci(d1, d2))]

Instantiating the top quantifier in -4 with the terms: 
 d1, d2,
this simplifies to: 
ci_dd :  

[-1]  real_pred(d1)
[-2]  real_pred(d2)
[-3]  d1 /= d2 IMPLIES not_one_element?[(ci(d1, d2))]
{-4}  d1 /= d2 IMPLIES connected?[(ci(d1, d2))]
  |-------
[1]   d1 = d2
[2]   connected? AND not_one_element?
[3]   deriv_domain?[(ci(d1, d2))]

Simplifying, rewriting, and recording with decision procedures,
Q.E.D.


Run time  = 0.03 secs.
Real time = 0.03 secs.

active_corner_certificate.ci_dd proved in 0.03 real, 0.03 cpu seconds
Rerunning proof of active_corner_certificate.mvt_gen_ge_TCC1
Installing rewrite rule sets.singleton_rew (all instances)
Installing rewrite rule analysis@lim_of_functions.adherence_fullset (all instances)
Installing rewrite rule reals@sq.sq_abs_neg
Installing rewrite rule reals@sq.sq_abs
Installing rewrite rule reals@sq.sq_1
Installing rewrite rule reals@sq.sq_0
Installing rewrite rule reals@abs_lems.abs_0
Installing rewrite rule reals@abs_lems.abs_nat
Installing rewrite rule sets.member (all instances)
Installing rewrite rule list_props.member (all instances)
mvt_gen_ge_TCC1 :  

  |-------
{1}   FORALL (D:
                {DD: [real -> bool] |
                   connected?[(DD)] AND not_one_element?[(DD)]},
              a, b: (D)):
        deriv_domain?[(D)]

Rerunning step: (THEN (SKEEP) (LEMMA "connected_deriv_domain[(D)]") (ASSERT))
Skolemizing and keeping names of the universal formula in (+ -),
this simplifies to: 
mvt_gen_ge_TCC1 :  

  |-------
{1}   deriv_domain?[(D)]

Applying connected_deriv_domain[(D)] 
this simplifies to: 
mvt_gen_ge_TCC1 :  

{-1}  connected? AND not_one_element? IMPLIES deriv_domain?
  |-------
[1]   deriv_domain?[(D)]

Simplifying, rewriting, and recording with decision procedures,
Q.E.D.


Run time  = 0.02 secs.
Real time = 0.02 secs.

active_corner_certificate.mvt_gen_ge_TCC1 proved in 0.02 real, 0.02 cpu seconds
Rerunning proof of active_corner_certificate.mvt_gen_ge_TCC2
Installing rewrite rule sets.singleton_rew (all instances)
Installing rewrite rule analysis@lim_of_functions.adherence_fullset (all instances)
Installing rewrite rule reals@sq.sq_abs_neg
Installing rewrite rule reals@sq.sq_abs
Installing rewrite rule reals@sq.sq_1
Installing rewrite rule reals@sq.sq_0
Installing rewrite rule reals@abs_lems.abs_0
Installing rewrite rule reals@abs_lems.abs_nat
Installing rewrite rule sets.member (all instances)
Installing rewrite rule list_props.member (all instances)
mvt_gen_ge_TCC2 :  

  |-------
{1}   FORALL (D:
                {DD: [real -> bool] |
                   connected?[(DD)] AND not_one_element?[(DD)]},
              a, b: (D)):
        not_one_element?[(D)]

Rerunning step: (THEN (ASSERT) (GRIND))
Simplifying, rewriting, and recording with decision procedures,
Q.E.D.


Run time  = 0.00 secs.
Real time = 0.00 secs.

active_corner_certificate.mvt_gen_ge_TCC2 proved in 0.00 real, 0.00 cpu seconds
Rerunning proof of active_corner_certificate.mvt_gen_ge
Installing rewrite rule sets.singleton_rew (all instances)
Installing rewrite rule analysis@lim_of_functions.adherence_fullset (all instances)
Installing rewrite rule reals@sq.sq_abs_neg
Installing rewrite rule reals@sq.sq_abs
Installing rewrite rule reals@sq.sq_1
Installing rewrite rule reals@sq.sq_0
Installing rewrite rule reals@abs_lems.abs_0
Installing rewrite rule reals@abs_lems.abs_nat
Installing rewrite rule sets.member (all instances)
Installing rewrite rule list_props.member (all instances)
mvt_gen_ge :  

  |-------
{1}   FORALL (f: [real -> real],
              D:
                {DD: [real -> bool] |
                   connected?[(DD)] AND not_one_element?[(DD)]},
              c: real, a, b: (D)):
        (derivable?[(D)](restrict[real, (D), real](f)) AND
          a >= b AND
           FORALL (x: (D)):
             deriv[(D)](restrict[real, (D), real](f))(x) >= c)
         IMPLIES f(a) - f(b) >= c * (a - b)

Rerunning step: (THEN (SKEEP)
                 (SPREAD (CASE "a=b")
                  ((ASSERT)
                   (THEN (LEMMA "mean_value[(D)]") (INST -1 "b" "a" "f")
                    (ASSERT) (SKEEP) (INST -6 "c!1") (EXPAND "deriv" -6)
                    (ASSERT) (MULT-BY -6 "a-b") (ASSERT) (EXPAND "restrict")
                    (ASSERT)))))
Skolemizing and keeping names of the universal formula in (+ -),
this simplifies to: 
mvt_gen_ge :  

{-1}  derivable?[(D)](restrict[real, (D), real](f))
{-2}  a >= b
{-3}  FORALL (x: (D)): deriv[(D)](restrict[real, (D), real](f))(x) >= c
  |-------
{1}   f(a) - f(b) >= c * (a - b)

Case splitting on 
   a = b, 
this yields  2 subgoals: 
mvt_gen_ge.1 :  

{-1}  a = b
[-2]  derivable?[(D)](restrict[real, (D), real](f))
[-3]  a >= b
[-4]  FORALL (x: (D)): deriv[(D)](restrict[real, (D), real](f))(x) >= c
  |-------
[1]   f(a) - f(b) >= c * (a - b)

Simplifying, rewriting, and recording with decision procedures,

This completes the proof of mvt_gen_ge.1.

mvt_gen_ge.2 :  

[-1]  derivable?[(D)](restrict[real, (D), real](f))
[-2]  a >= b
[-3]  FORALL (x: (D)): deriv[(D)](restrict[real, (D), real](f))(x) >= c
  |-------
{1}   a = b
[2]   f(a) - f(b) >= c * (a - b)

Applying mean_value[(D)] 
this simplifies to: 
mvt_gen_ge.2 :  

{-1}  FORALL (a, b: (D), f: [(D) -> real]):
        derivable?(f) AND a < b IMPLIES
         EXISTS (c: (D)):
           a < c AND c < b AND deriv(f, c) * (b - a) = f(b) - f(a)
[-2]  derivable?[(D)](restrict[real, (D), real](f))
[-3]  a >= b
[-4]  FORALL (x: (D)): deriv[(D)](restrict[real, (D), real](f))(x) >= c
  |-------
[1]   a = b
[2]   f(a) - f(b) >= c * (a - b)


 In input "f":
  added conversion restrict[real, (D), real]
             
  to f, converting
     [real -> real]
  to [(D) -> real]

Instantiating the top quantifier in -1 with the terms: 
 b, a, f,
this simplifies to: 
mvt_gen_ge.2 :  

{-1}  derivable?(restrict[real, (D), real](f)) AND b < a IMPLIES
       EXISTS (c: (D)):
         b < c AND
          c < a AND
           deriv(restrict[real, (D), real](f), c) * (a - b) =
            restrict[real, (D), real](f)(a) -
             restrict[real, (D), real](f)(b)
[-2]  derivable?[(D)](restrict[real, (D), real](f))
[-3]  a >= b
[-4]  FORALL (x: (D)): deriv[(D)](restrict[real, (D), real](f))(x) >= c
  |-------
[1]   a = b
[2]   f(a) - f(b) >= c * (a - b)

Simplifying, rewriting, and recording with decision procedures,
this simplifies to: 
mvt_gen_ge.2 :  

{-1}  EXISTS (c: (D)):
        b < c AND
         c < a AND
          deriv(restrict[real, (D), real](f), c) * a -
           deriv(restrict[real, (D), real](f), c) * b
           =
           restrict[real, (D), real](f)(a) - restrict[real, (D), real](f)(b)
[-2]  derivable?[(D)](restrict[real, (D), real](f))
[-3]  a >= b
[-4]  FORALL (x: (D)): deriv[(D)](restrict[real, (D), real](f))(x) >= c
  |-------
[1]   a = b
{2}   f(a) - f(b) >= a * c - b * c

Skolemizing and keeping names of the universal formula in (+ -),
this simplifies to: 
mvt_gen_ge.2 :  

{-1}  b < c!1
{-2}  c!1 < a
{-3}  deriv(restrict[real, (D), real](f), c!1) * a -
       deriv(restrict[real, (D), real](f), c!1) * b
       = restrict[real, (D), real](f)(a) - restrict[real, (D), real](f)(b)
[-4]  derivable?[(D)](restrict[real, (D), real](f))
[-5]  a >= b
[-6]  FORALL (x: (D)): deriv[(D)](restrict[real, (D), real](f))(x) >= c
  |-------
[1]   a = b
[2]   f(a) - f(b) >= a * c - b * c

Instantiating the top quantifier in -6 with the terms: 
 c!1,
this simplifies to: 
mvt_gen_ge.2 :  

[-1]  b < c!1
[-2]  c!1 < a
[-3]  deriv(restrict[real, (D), real](f), c!1) * a -
       deriv(restrict[real, (D), real](f), c!1) * b
       = restrict[real, (D), real](f)(a) - restrict[real, (D), real](f)(b)
[-4]  derivable?[(D)](restrict[real, (D), real](f))
[-5]  a >= b
{-6}  deriv[(D)](restrict[real, (D), real](f))(c!1) >= c
  |-------
[1]   a = b
[2]   f(a) - f(b) >= a * c - b * c

Expanding the definition of deriv,
this simplifies to: 
mvt_gen_ge.2 :  

[-1]  b < c!1
[-2]  c!1 < a
[-3]  deriv(restrict[real, (D), real](f), c!1) * a -
       deriv(restrict[real, (D), real](f), c!1) * b
       = restrict[real, (D), real](f)(a) - restrict[real, (D), real](f)(b)
[-4]  derivable?[(D)](restrict[real, (D), real](f))
[-5]  a >= b
{-6}  deriv[(D)](restrict[real, (D), real](f), c!1) >= c
  |-------
[1]   a = b
[2]   f(a) - f(b) >= a * c - b * c

Simplifying, rewriting, and recording with decision procedures,
this simplifies to: 
mvt_gen_ge.2 :  

[-1]  b < c!1
[-2]  c!1 < a
[-3]  deriv(restrict[real, (D), real](f), c!1) * a -
       deriv(restrict[real, (D), real](f), c!1) * b
       = restrict[real, (D), real](f)(a) - restrict[real, (D), real](f)(b)
[-4]  derivable?[(D)](restrict[real, (D), real](f))
[-5]  a >= b
[-6]  deriv[(D)](restrict[real, (D), real](f), c!1) >= c
  |-------
[1]   a = b
[2]   f(a) - f(b) >= a * c - b * c

Multiplying both sides of selected formulas by given term,
this simplifies to: 
mvt_gen_ge.2 :  

{-1}  deriv[(D)](restrict[real, (D), real](f), c!1) * (a - b) >= c * (a - b)
[-2]  b < c!1
[-3]  c!1 < a
[-4]  deriv(restrict[real, (D), real](f), c!1) * a -
       deriv(restrict[real, (D), real](f), c!1) * b
       = restrict[real, (D), real](f)(a) - restrict[real, (D), real](f)(b)
[-5]  derivable?[(D)](restrict[real, (D), real](f))
[-6]  a >= b
  |-------
[1]   a = b
[2]   f(a) - f(b) >= a * c - b * c

Simplifying, rewriting, and recording with decision procedures,
this simplifies to: 
mvt_gen_ge.2 :  

{-1}  deriv[(D)](restrict[real, (D), real](f), c!1) * a -
       deriv[(D)](restrict[real, (D), real](f), c!1) * b
       >= a * c - b * c
[-2]  b < c!1
[-3]  c!1 < a
[-4]  deriv(restrict[real, (D), real](f), c!1) * a -
       deriv(restrict[real, (D), real](f), c!1) * b
       = restrict[real, (D), real](f)(a) - restrict[real, (D), real](f)(b)
[-5]  derivable?[(D)](restrict[real, (D), real](f))
[-6]  a >= b
  |-------
[1]   a = b
[2]   f(a) - f(b) >= a * c - b * c

Expanding the definition of restrict,
this simplifies to: 
mvt_gen_ge.2 :  

{-1}  deriv[(D)](LAMBDA (s: (D)): f(s), c!1) * a -
       deriv[(D)](LAMBDA (s: (D)): f(s), c!1) * b
       >= a * c - b * c
[-2]  b < c!1
[-3]  c!1 < a
{-4}  deriv(LAMBDA (s: (D)): f(s), c!1) * a -
       deriv(LAMBDA (s: (D)): f(s), c!1) * b
       = f(a) - f(b)
{-5}  derivable?[(D)](LAMBDA (s: (D)): f(s))
[-6]  a >= b
  |-------
[1]   a = b
[2]   f(a) - f(b) >= a * c - b * c

Simplifying, rewriting, and recording with decision procedures,

This completes the proof of mvt_gen_ge.2.

Q.E.D.


Run time  = 0.13 secs.
Real time = 0.13 secs.

active_corner_certificate.mvt_gen_ge proved in 0.13 real, 0.13 cpu seconds
Rerunning proof of active_corner_certificate.mvt_gen_le
Installing rewrite rule sets.singleton_rew (all instances)
Installing rewrite rule analysis@lim_of_functions.adherence_fullset (all instances)
Installing rewrite rule reals@sq.sq_abs_neg
Installing rewrite rule reals@sq.sq_abs
Installing rewrite rule reals@sq.sq_1
Installing rewrite rule reals@sq.sq_0
Installing rewrite rule reals@abs_lems.abs_0
Installing rewrite rule reals@abs_lems.abs_nat
Installing rewrite rule sets.member (all instances)
Installing rewrite rule list_props.member (all instances)
mvt_gen_le :  

  |-------
{1}   FORALL (f: [real -> real],
              D:
                {DD: [real -> bool] |
                   connected?[(DD)] AND not_one_element?[(DD)]},
              c: real, a, b: (D)):
        (derivable?[(D)](restrict[real, (D), real](f)) AND
          a >= b AND
           FORALL (x: (D)):
             deriv[(D)](restrict[real, (D), real](f))(x) <= c)
         IMPLIES f(a) - f(b) <= c * (a - b)

Rerunning step: (THEN (SKEEP)
                 (SPREAD (CASE "a=b")
                  ((ASSERT)
                   (THEN (LEMMA "mean_value[(D)]") (INST -1 "b" "a" "f")
                    (ASSERT) (SKEEP) (INST -6 "c!1") (EXPAND "deriv" -6)
                    (ASSERT) (MULT-BY -6 "a-b") (ASSERT) (EXPAND "restrict")
                    (ASSERT)))))
Skolemizing and keeping names of the universal formula in (+ -),
this simplifies to: 
mvt_gen_le :  

{-1}  derivable?[(D)](restrict[real, (D), real](f))
{-2}  a >= b
{-3}  FORALL (x: (D)): deriv[(D)](restrict[real, (D), real](f))(x) <= c
  |-------
{1}   f(a) - f(b) <= c * (a - b)

Case splitting on 
   a = b, 
this yields  2 subgoals: 
mvt_gen_le.1 :  

{-1}  a = b
[-2]  derivable?[(D)](restrict[real, (D), real](f))
[-3]  a >= b
[-4]  FORALL (x: (D)): deriv[(D)](restrict[real, (D), real](f))(x) <= c
  |-------
[1]   f(a) - f(b) <= c * (a - b)

Simplifying, rewriting, and recording with decision procedures,

This completes the proof of mvt_gen_le.1.

mvt_gen_le.2 :  

[-1]  derivable?[(D)](restrict[real, (D), real](f))
[-2]  a >= b
[-3]  FORALL (x: (D)): deriv[(D)](restrict[real, (D), real](f))(x) <= c
  |-------
{1}   a = b
[2]   f(a) - f(b) <= c * (a - b)

Applying mean_value[(D)] 
this simplifies to: 
mvt_gen_le.2 :  

{-1}  FORALL (a, b: (D), f: [(D) -> real]):
        derivable?(f) AND a < b IMPLIES
         EXISTS (c: (D)):
           a < c AND c < b AND deriv(f, c) * (b - a) = f(b) - f(a)
[-2]  derivable?[(D)](restrict[real, (D), real](f))
[-3]  a >= b
[-4]  FORALL (x: (D)): deriv[(D)](restrict[real, (D), real](f))(x) <= c
  |-------
[1]   a = b
[2]   f(a) - f(b) <= c * (a - b)


 In input "f":
  added conversion restrict[real, (D), real]
             
  to f, converting
     [real -> real]
  to [(D) -> real]

Instantiating the top quantifier in -1 with the terms: 
 b, a, f,
this simplifies to: 
mvt_gen_le.2 :  

{-1}  derivable?(restrict[real, (D), real](f)) AND b < a IMPLIES
       EXISTS (c: (D)):
         b < c AND
          c < a AND
           deriv(restrict[real, (D), real](f), c) * (a - b) =
            restrict[real, (D), real](f)(a) -
             restrict[real, (D), real](f)(b)
[-2]  derivable?[(D)](restrict[real, (D), real](f))
[-3]  a >= b
[-4]  FORALL (x: (D)): deriv[(D)](restrict[real, (D), real](f))(x) <= c
  |-------
[1]   a = b
[2]   f(a) - f(b) <= c * (a - b)

Simplifying, rewriting, and recording with decision procedures,
this simplifies to: 
mvt_gen_le.2 :  

{-1}  EXISTS (c: (D)):
        b < c AND
         c < a AND
          deriv(restrict[real, (D), real](f), c) * a -
           deriv(restrict[real, (D), real](f), c) * b
           =
           restrict[real, (D), real](f)(a) - restrict[real, (D), real](f)(b)
[-2]  derivable?[(D)](restrict[real, (D), real](f))
[-3]  a >= b
[-4]  FORALL (x: (D)): deriv[(D)](restrict[real, (D), real](f))(x) <= c
  |-------
[1]   a = b
{2}   f(a) - f(b) <= a * c - b * c

Skolemizing and keeping names of the universal formula in (+ -),
this simplifies to: 
mvt_gen_le.2 :  

{-1}  b < c!1
{-2}  c!1 < a
{-3}  deriv(restrict[real, (D), real](f), c!1) * a -
       deriv(restrict[real, (D), real](f), c!1) * b
       = restrict[real, (D), real](f)(a) - restrict[real, (D), real](f)(b)
[-4]  derivable?[(D)](restrict[real, (D), real](f))
[-5]  a >= b
[-6]  FORALL (x: (D)): deriv[(D)](restrict[real, (D), real](f))(x) <= c
  |-------
[1]   a = b
[2]   f(a) - f(b) <= a * c - b * c

Instantiating the top quantifier in -6 with the terms: 
 c!1,
this simplifies to: 
mvt_gen_le.2 :  

[-1]  b < c!1
[-2]  c!1 < a
[-3]  deriv(restrict[real, (D), real](f), c!1) * a -
       deriv(restrict[real, (D), real](f), c!1) * b
       = restrict[real, (D), real](f)(a) - restrict[real, (D), real](f)(b)
[-4]  derivable?[(D)](restrict[real, (D), real](f))
[-5]  a >= b
{-6}  deriv[(D)](restrict[real, (D), real](f))(c!1) <= c
  |-------
[1]   a = b
[2]   f(a) - f(b) <= a * c - b * c

Expanding the definition of deriv,
this simplifies to: 
mvt_gen_le.2 :  

[-1]  b < c!1
[-2]  c!1 < a
[-3]  deriv(restrict[real, (D), real](f), c!1) * a -
       deriv(restrict[real, (D), real](f), c!1) * b
       = restrict[real, (D), real](f)(a) - restrict[real, (D), real](f)(b)
[-4]  derivable?[(D)](restrict[real, (D), real](f))
[-5]  a >= b
{-6}  deriv[(D)](restrict[real, (D), real](f), c!1) <= c
  |-------
[1]   a = b
[2]   f(a) - f(b) <= a * c - b * c

Simplifying, rewriting, and recording with decision procedures,
this simplifies to: 
mvt_gen_le.2 :  

[-1]  b < c!1
[-2]  c!1 < a
[-3]  deriv(restrict[real, (D), real](f), c!1) * a -
       deriv(restrict[real, (D), real](f), c!1) * b
       = restrict[real, (D), real](f)(a) - restrict[real, (D), real](f)(b)
[-4]  derivable?[(D)](restrict[real, (D), real](f))
[-5]  a >= b
[-6]  deriv[(D)](restrict[real, (D), real](f), c!1) <= c
  |-------
[1]   a = b
[2]   f(a) - f(b) <= a * c - b * c

Multiplying both sides of selected formulas by given term,
this simplifies to: 
mvt_gen_le.2 :  

{-1}  deriv[(D)](restrict[real, (D), real](f), c!1) * (a - b) <= c * (a - b)
[-2]  b < c!1
[-3]  c!1 < a
[-4]  deriv(restrict[real, (D), real](f), c!1) * a -
       deriv(restrict[real, (D), real](f), c!1) * b
       = restrict[real, (D), real](f)(a) - restrict[real, (D), real](f)(b)
[-5]  derivable?[(D)](restrict[real, (D), real](f))
[-6]  a >= b
  |-------
[1]   a = b
[2]   f(a) - f(b) <= a * c - b * c

Simplifying, rewriting, and recording with decision procedures,
this simplifies to: 
mvt_gen_le.2 :  

{-1}  deriv[(D)](restrict[real, (D), real](f), c!1) * a -
       deriv[(D)](restrict[real, (D), real](f), c!1) * b
       <= a * c - b * c
[-2]  b < c!1
[-3]  c!1 < a
[-4]  deriv(restrict[real, (D), real](f), c!1) * a -
       deriv(restrict[real, (D), real](f), c!1) * b
       = restrict[real, (D), real](f)(a) - restrict[real, (D), real](f)(b)
[-5]  derivable?[(D)](restrict[real, (D), real](f))
[-6]  a >= b
  |-------
[1]   a = b
[2]   f(a) - f(b) <= a * c - b * c

Expanding the definition of restrict,
this simplifies to: 
mvt_gen_le.2 :  

{-1}  deriv[(D)](LAMBDA (s: (D)): f(s), c!1) * a -
       deriv[(D)](LAMBDA (s: (D)): f(s), c!1) * b
       <= a * c - b * c
[-2]  b < c!1
[-3]  c!1 < a
{-4}  deriv(LAMBDA (s: (D)): f(s), c!1) * a -
       deriv(LAMBDA (s: (D)): f(s), c!1) * b
       = f(a) - f(b)
{-5}  derivable?[(D)](LAMBDA (s: (D)): f(s))
[-6]  a >= b
  |-------
[1]   a = b
[2]   f(a) - f(b) <= a * c - b * c

Simplifying, rewriting, and recording with decision procedures,

This completes the proof of mvt_gen_le.2.

Q.E.D.


Run time  = 0.12 secs.
Real time = 0.12 secs.

active_corner_certificate.mvt_gen_le proved in 0.12 real, 0.12 cpu seconds
Rerunning proof of active_corner_certificate.mvt_gen_ge_lo_TCC1
Installing rewrite rule sets.singleton_rew (all instances)
Installing rewrite rule analysis@lim_of_functions.adherence_fullset (all instances)
Installing rewrite rule reals@sq.sq_abs_neg
Installing rewrite rule reals@sq.sq_abs
Installing rewrite rule reals@sq.sq_1
Installing rewrite rule reals@sq.sq_0
Installing rewrite rule reals@abs_lems.abs_0
Installing rewrite rule reals@abs_lems.abs_nat
Installing rewrite rule sets.member (all instances)
Installing rewrite rule list_props.member (all instances)
mvt_gen_ge_lo_TCC1 :  

  |-------
{1}   FORALL (C: real, a, b: (left_open(C))): deriv_domain?[(left_open(C))]

Rerunning step: (THEN (SKEEP) (LEMMA "left_open_dd") (INST -1 "C") (ASSERT)
                 (GRIND))
Skolemizing and keeping names of the universal formula in (+ -),
this simplifies to: 
mvt_gen_ge_lo_TCC1 :  

  |-------
{1}   deriv_domain?[(left_open(C))]

Applying left_open_dd 
this simplifies to: 
mvt_gen_ge_lo_TCC1 :  

{-1}  FORALL (c: real): deriv_domain?[(left_open(c))]
  |-------
[1]   deriv_domain?[(left_open(C))]

Instantiating the top quantifier in -1 with the terms: 
 C,
Q.E.D.


Run time  = 0.02 secs.
Real time = 0.02 secs.

active_corner_certificate.mvt_gen_ge_lo_TCC1 proved in 0.02 real, 0.02 cpu seconds
Rerunning proof of active_corner_certificate.mvt_gen_ge_lo_TCC2
Installing rewrite rule sets.singleton_rew (all instances)
Installing rewrite rule analysis@lim_of_functions.adherence_fullset (all instances)
Installing rewrite rule reals@sq.sq_abs_neg
Installing rewrite rule reals@sq.sq_abs
Installing rewrite rule reals@sq.sq_1
Installing rewrite rule reals@sq.sq_0
Installing rewrite rule reals@abs_lems.abs_0
Installing rewrite rule reals@abs_lems.abs_nat
Installing rewrite rule sets.member (all instances)
Installing rewrite rule list_props.member (all instances)
mvt_gen_ge_lo_TCC2 :  

  |-------
{1}   FORALL (C: real, a, b: (left_open(C))):
        not_one_element?[(left_open(C))]

Rerunning step: (THEN (SKEEP) (LEMMA "left_open_noe") (INST -1 "C") (ASSERT)
                 (GRIND))
Skolemizing and keeping names of the universal formula in (+ -),
this simplifies to: 
mvt_gen_ge_lo_TCC2 :  

  |-------
{1}   not_one_element?[(left_open(C))]

Applying left_open_noe 
this simplifies to: 
mvt_gen_ge_lo_TCC2 :  

{-1}  FORALL (c: real): not_one_element?[(left_open(c))]
  |-------
[1]   not_one_element?[(left_open(C))]

Instantiating the top quantifier in -1 with the terms: 
 C,
Q.E.D.


Run time  = 0.01 secs.
Real time = 0.01 secs.

active_corner_certificate.mvt_gen_ge_lo_TCC2 proved in 0.01 real, 0.01 cpu seconds
Rerunning proof of active_corner_certificate.mvt_gen_ge_lo
Installing rewrite rule sets.singleton_rew (all instances)
Installing rewrite rule analysis@lim_of_functions.adherence_fullset (all instances)
Installing rewrite rule reals@sq.sq_abs_neg
Installing rewrite rule reals@sq.sq_abs
Installing rewrite rule reals@sq.sq_1
Installing rewrite rule reals@sq.sq_0
Installing rewrite rule reals@abs_lems.abs_0
Installing rewrite rule reals@abs_lems.abs_nat
Installing rewrite rule sets.member (all instances)
Installing rewrite rule list_props.member (all instances)
mvt_gen_ge_lo :  

  |-------
{1}   FORALL (f: [real -> real], C, c: real, a, b: (left_open(C))):
        (derivable?[(left_open(C))]
             (restrict[real, (left_open(C)), real](f))
          AND
          a >= b AND
           FORALL (x: (left_open(C))):
             deriv[(left_open(C))]
                 (restrict[real, (left_open(C)), real](f))(x)
              >= c)
         IMPLIES f(a) - f(b) >= c * (a - b)

Rerunning step: (THEN (LEMMA "mvt_gen_ge") (SKEEP)
                 (SPREAD (INST -1 "f" "left_open(C)" "c" "a" "b")
                  ((ASSERT)
                   (THEN (LEMMA "left_open_noe") (LEMMA " left_open_connected")
                    (INST -1 "C") (INST -2 "C") (ASSERT)))))
Applying mvt_gen_ge 
this simplifies to: 
mvt_gen_ge_lo :  

{-1}  FORALL (f: [real -> real],
              D:
                {DD: [real -> bool] |
                   connected?[(DD)] AND not_one_element?[(DD)]},
              c: real, a, b: (D)):
        (derivable?[(D)](restrict[real, (D), real](f)) AND
          a >= b AND
           FORALL (x: (D)):
             deriv[(D)](restrict[real, (D), real](f))(x) >= c)
         IMPLIES f(a) - f(b) >= c * (a - b)
  |-------
[1]   FORALL (f: [real -> real], C, c: real, a, b: (left_open(C))):
        (derivable?[(left_open(C))]
             (restrict[real, (left_open(C)), real](f))
          AND
          a >= b AND
           FORALL (x: (left_open(C))):
             deriv[(left_open(C))]
                 (restrict[real, (left_open(C)), real](f))(x)
              >= c)
         IMPLIES f(a) - f(b) >= c * (a - b)

Skolemizing and keeping names of the universal formula in (+ -),
this simplifies to: 
mvt_gen_ge_lo :  

[-1]  FORALL (f: [real -> real],
              D:
                {DD: [real -> bool] |
                   connected?[(DD)] AND not_one_element?[(DD)]},
              c: real, a, b: (D)):
        (derivable?[(D)](restrict[real, (D), real](f)) AND
          a >= b AND
           FORALL (x: (D)):
             deriv[(D)](restrict[real, (D), real](f))(x) >= c)
         IMPLIES f(a) - f(b) >= c * (a - b)
{-2}  derivable?[(left_open(C))](restrict[real, (left_open(C)), real](f))
{-3}  a >= b
{-4}  FORALL (x: (left_open(C))):
        deriv[(left_open(C))](restrict[real, (left_open(C)), real](f))(x)
         >= c
  |-------
{1}   f(a) - f(b) >= c * (a - b)

Instantiating the top quantifier in -1 with the terms: 
 f, left_open(C), c, a, b,
this yields  2 subgoals: 
mvt_gen_ge_lo.1 :  

{-1}  (derivable?[(left_open(C))](restrict[real, (left_open(C)), real](f))
        AND
        a >= b AND
         FORALL (x: (left_open(C))):
           deriv[(left_open(C))]
               (restrict[real, (left_open(C)), real](f))(x)
            >= c)
       IMPLIES f(a) - f(b) >= c * (a - b)
[-2]  derivable?[(left_open(C))](restrict[real, (left_open(C)), real](f))
[-3]  a >= b
[-4]  FORALL (x: (left_open(C))):
        deriv[(left_open(C))](restrict[real, (left_open(C)), real](f))(x)
         >= c
  |-------
[1]   f(a) - f(b) >= c * (a - b)

Simplifying, rewriting, and recording with decision procedures,

This completes the proof of mvt_gen_ge_lo.1.

mvt_gen_ge_lo.2 (TCC):   

[-1]  derivable?[(left_open(C))](restrict[real, (left_open(C)), real](f))
[-2]  a >= b
[-3]  FORALL (x: (left_open(C))):
        deriv[(left_open(C))](restrict[real, (left_open(C)), real](f))(x)
         >= c
  |-------
{1}   connected?[(left_open(C))] AND not_one_element?[(left_open(C))]
[2]   f(a) - f(b) >= c * (a - b)

Applying left_open_noe 
this simplifies to: 
mvt_gen_ge_lo.2 :  

{-1}  FORALL (c: real): not_one_element?[(left_open(c))]
[-2]  derivable?[(left_open(C))](restrict[real, (left_open(C)), real](f))
[-3]  a >= b
[-4]  FORALL (x: (left_open(C))):
        deriv[(left_open(C))](restrict[real, (left_open(C)), real](f))(x)
         >= c
  |-------
[1]   connected?[(left_open(C))] AND not_one_element?[(left_open(C))]
[2]   f(a) - f(b) >= c * (a - b)

Applying left_open_connected 
this simplifies to: 
mvt_gen_ge_lo.2 :  

{-1}  FORALL (c: real): connected?[(left_open(c))]
[-2]  FORALL (c: real): not_one_element?[(left_open(c))]
[-3]  derivable?[(left_open(C))](restrict[real, (left_open(C)), real](f))
[-4]  a >= b
[-5]  FORALL (x: (left_open(C))):
        deriv[(left_open(C))](restrict[real, (left_open(C)), real](f))(x)
         >= c
  |-------
[1]   connected?[(left_open(C))] AND not_one_element?[(left_open(C))]
[2]   f(a) - f(b) >= c * (a - b)

Instantiating the top quantifier in -1 with the terms: 
 C,
this simplifies to: 
mvt_gen_ge_lo.2 :  

{-1}  connected?[(left_open(C))]
[-2]  FORALL (c: real): not_one_element?[(left_open(c))]
[-3]  derivable?[(left_open(C))](restrict[real, (left_open(C)), real](f))
[-4]  a >= b
[-5]  FORALL (x: (left_open(C))):
        deriv[(left_open(C))](restrict[real, (left_open(C)), real](f))(x)
         >= c
  |-------
[1]   connected?[(left_open(C))] AND not_one_element?[(left_open(C))]
[2]   f(a) - f(b) >= c * (a - b)

Instantiating the top quantifier in -2 with the terms: 
 C,
this simplifies to: 
mvt_gen_ge_lo.2 :  

[-1]  connected?[(left_open(C))]
{-2}  not_one_element?[(left_open(C))]
[-3]  derivable?[(left_open(C))](restrict[real, (left_open(C)), real](f))
[-4]  a >= b
[-5]  FORALL (x: (left_open(C))):
        deriv[(left_open(C))](restrict[real, (left_open(C)), real](f))(x)
         >= c
  |-------
[1]   connected?[(left_open(C))] AND not_one_element?[(left_open(C))]
[2]   f(a) - f(b) >= c * (a - b)

Simplifying, rewriting, and recording with decision procedures,

This completes the proof of mvt_gen_ge_lo.2.

Q.E.D.


Run time  = 0.06 secs.
Real time = 0.06 secs.

active_corner_certificate.mvt_gen_ge_lo proved in 0.06 real, 0.06 cpu seconds
Rerunning proof of active_corner_certificate.mvt_gen_le_lo
Installing rewrite rule sets.singleton_rew (all instances)
Installing rewrite rule analysis@lim_of_functions.adherence_fullset (all instances)
Installing rewrite rule reals@sq.sq_abs_neg
Installing rewrite rule reals@sq.sq_abs
Installing rewrite rule reals@sq.sq_1
Installing rewrite rule reals@sq.sq_0
Installing rewrite rule reals@abs_lems.abs_0
Installing rewrite rule reals@abs_lems.abs_nat
Installing rewrite rule sets.member (all instances)
Installing rewrite rule list_props.member (all instances)
mvt_gen_le_lo :  

  |-------
{1}   FORALL (f: [real -> real], C, c: real, a, b: (left_open(C))):
        (derivable?[(left_open(C))]
             (restrict[real, (left_open(C)), real](f))
          AND
          a >= b AND
           FORALL (x: (left_open(C))):
             deriv[(left_open(C))]
                 (restrict[real, (left_open(C)), real](f))(x)
              <= c)
         IMPLIES f(a) - f(b) <= c * (a - b)

Rerunning step: (THEN (LEMMA "mvt_gen_le") (SKEEP)
                 (SPREAD (INST -1 "f" "left_open(C)" "c" "a" "b")
                  ((ASSERT)
                   (THEN (LEMMA "left_open_noe") (LEMMA " left_open_connected")
                    (INST -1 "C") (INST -2 "C") (ASSERT)))))
Applying mvt_gen_le 
this simplifies to: 
mvt_gen_le_lo :  

{-1}  FORALL (f: [real -> real],
              D:
                {DD: [real -> bool] |
                   connected?[(DD)] AND not_one_element?[(DD)]},
              c: real, a, b: (D)):
        (derivable?[(D)](restrict[real, (D), real](f)) AND
          a >= b AND
           FORALL (x: (D)):
             deriv[(D)](restrict[real, (D), real](f))(x) <= c)
         IMPLIES f(a) - f(b) <= c * (a - b)
  |-------
[1]   FORALL (f: [real -> real], C, c: real, a, b: (left_open(C))):
        (derivable?[(left_open(C))]
             (restrict[real, (left_open(C)), real](f))
          AND
          a >= b AND
           FORALL (x: (left_open(C))):
             deriv[(left_open(C))]
                 (restrict[real, (left_open(C)), real](f))(x)
              <= c)
         IMPLIES f(a) - f(b) <= c * (a - b)

Skolemizing and keeping names of the universal formula in (+ -),
this simplifies to: 
mvt_gen_le_lo :  

[-1]  FORALL (f: [real -> real],
              D:
                {DD: [real -> bool] |
                   connected?[(DD)] AND not_one_element?[(DD)]},
              c: real, a, b: (D)):
        (derivable?[(D)](restrict[real, (D), real](f)) AND
          a >= b AND
           FORALL (x: (D)):
             deriv[(D)](restrict[real, (D), real](f))(x) <= c)
         IMPLIES f(a) - f(b) <= c * (a - b)
{-2}  derivable?[(left_open(C))](restrict[real, (left_open(C)), real](f))
{-3}  a >= b
{-4}  FORALL (x: (left_open(C))):
        deriv[(left_open(C))](restrict[real, (left_open(C)), real](f))(x)
         <= c
  |-------
{1}   f(a) - f(b) <= c * (a - b)

Instantiating the top quantifier in -1 with the terms: 
 f, left_open(C), c, a, b,
this yields  2 subgoals: 
mvt_gen_le_lo.1 :  

{-1}  (derivable?[(left_open(C))](restrict[real, (left_open(C)), real](f))
        AND
        a >= b AND
         FORALL (x: (left_open(C))):
           deriv[(left_open(C))]
               (restrict[real, (left_open(C)), real](f))(x)
            <= c)
       IMPLIES f(a) - f(b) <= c * (a - b)
[-2]  derivable?[(left_open(C))](restrict[real, (left_open(C)), real](f))
[-3]  a >= b
[-4]  FORALL (x: (left_open(C))):
        deriv[(left_open(C))](restrict[real, (left_open(C)), real](f))(x)
         <= c
  |-------
[1]   f(a) - f(b) <= c * (a - b)

Simplifying, rewriting, and recording with decision procedures,

This completes the proof of mvt_gen_le_lo.1.

mvt_gen_le_lo.2 (TCC):   

[-1]  derivable?[(left_open(C))](restrict[real, (left_open(C)), real](f))
[-2]  a >= b
[-3]  FORALL (x: (left_open(C))):
        deriv[(left_open(C))](restrict[real, (left_open(C)), real](f))(x)
         <= c
  |-------
{1}   connected?[(left_open(C))] AND not_one_element?[(left_open(C))]
[2]   f(a) - f(b) <= c * (a - b)

Applying left_open_noe 
this simplifies to: 
mvt_gen_le_lo.2 :  

{-1}  FORALL (c: real): not_one_element?[(left_open(c))]
[-2]  derivable?[(left_open(C))](restrict[real, (left_open(C)), real](f))
[-3]  a >= b
[-4]  FORALL (x: (left_open(C))):
        deriv[(left_open(C))](restrict[real, (left_open(C)), real](f))(x)
         <= c
  |-------
[1]   connected?[(left_open(C))] AND not_one_element?[(left_open(C))]
[2]   f(a) - f(b) <= c * (a - b)

Applying left_open_connected 
this simplifies to: 
mvt_gen_le_lo.2 :  

{-1}  FORALL (c: real): connected?[(left_open(c))]
[-2]  FORALL (c: real): not_one_element?[(left_open(c))]
[-3]  derivable?[(left_open(C))](restrict[real, (left_open(C)), real](f))
[-4]  a >= b
[-5]  FORALL (x: (left_open(C))):
        deriv[(left_open(C))](restrict[real, (left_open(C)), real](f))(x)
         <= c
  |-------
[1]   connected?[(left_open(C))] AND not_one_element?[(left_open(C))]
[2]   f(a) - f(b) <= c * (a - b)

Instantiating the top quantifier in -1 with the terms: 
 C,
this simplifies to: 
mvt_gen_le_lo.2 :  

{-1}  connected?[(left_open(C))]
[-2]  FORALL (c: real): not_one_element?[(left_open(c))]
[-3]  derivable?[(left_open(C))](restrict[real, (left_open(C)), real](f))
[-4]  a >= b
[-5]  FORALL (x: (left_open(C))):
        deriv[(left_open(C))](restrict[real, (left_open(C)), real](f))(x)
         <= c
  |-------
[1]   connected?[(left_open(C))] AND not_one_element?[(left_open(C))]
[2]   f(a) - f(b) <= c * (a - b)

Instantiating the top quantifier in -2 with the terms: 
 C,
this simplifies to: 
mvt_gen_le_lo.2 :  

[-1]  connected?[(left_open(C))]
{-2}  not_one_element?[(left_open(C))]
[-3]  derivable?[(left_open(C))](restrict[real, (left_open(C)), real](f))
[-4]  a >= b
[-5]  FORALL (x: (left_open(C))):
        deriv[(left_open(C))](restrict[real, (left_open(C)), real](f))(x)
         <= c
  |-------
[1]   connected?[(left_open(C))] AND not_one_element?[(left_open(C))]
[2]   f(a) - f(b) <= c * (a - b)

Simplifying, rewriting, and recording with decision procedures,

This completes the proof of mvt_gen_le_lo.2.

Q.E.D.


Run time  = 0.05 secs.
Real time = 0.05 secs.

active_corner_certificate.mvt_gen_le_lo proved in 0.05 real, 0.05 cpu seconds
Rerunning proof of active_corner_certificate.mvt_gen_ge_ro_TCC1
Installing rewrite rule sets.singleton_rew (all instances)
Installing rewrite rule analysis@lim_of_functions.adherence_fullset (all instances)
Installing rewrite rule reals@sq.sq_abs_neg
Installing rewrite rule reals@sq.sq_abs
Installing rewrite rule reals@sq.sq_1
Installing rewrite rule reals@sq.sq_0
Installing rewrite rule reals@abs_lems.abs_0
Installing rewrite rule reals@abs_lems.abs_nat
Installing rewrite rule sets.member (all instances)
Installing rewrite rule list_props.member (all instances)
mvt_gen_ge_ro_TCC1 :  

  |-------
{1}   FORALL (C: real, a, b: (right_open(C))):
        deriv_domain?[(right_open(C))]

Rerunning step: (THEN (SKEEP) (LEMMA "right_open_dd") (INST -1 "C") (ASSERT)
                 (GRIND))
Skolemizing and keeping names of the universal formula in (+ -),
this simplifies to: 
mvt_gen_ge_ro_TCC1 :  

  |-------
{1}   deriv_domain?[(right_open(C))]

Applying right_open_dd 
this simplifies to: 
mvt_gen_ge_ro_TCC1 :  

{-1}  FORALL (c: real): deriv_domain?[(right_open(c))]
  |-------
[1]   deriv_domain?[(right_open(C))]

Instantiating the top quantifier in -1 with the terms: 
 C,
Q.E.D.


Run time  = 0.01 secs.
Real time = 0.01 secs.

active_corner_certificate.mvt_gen_ge_ro_TCC1 proved in 0.01 real, 0.01 cpu seconds
Rerunning proof of active_corner_certificate.mvt_gen_ge_ro_TCC2
Installing rewrite rule sets.singleton_rew (all instances)
Installing rewrite rule analysis@lim_of_functions.adherence_fullset (all instances)
Installing rewrite rule reals@sq.sq_abs_neg
Installing rewrite rule reals@sq.sq_abs
Installing rewrite rule reals@sq.sq_1
Installing rewrite rule reals@sq.sq_0
Installing rewrite rule reals@abs_lems.abs_0
Installing rewrite rule reals@abs_lems.abs_nat
Installing rewrite rule sets.member (all instances)
Installing rewrite rule list_props.member (all instances)
mvt_gen_ge_ro_TCC2 :  

  |-------
{1}   FORALL (C: real, a, b: (right_open(C))):
        not_one_element?[(right_open(C))]

Rerunning step: (THEN (SKEEP) (LEMMA "right_open_noe") (INST -1 "C") (ASSERT)
                 (GRIND))
Skolemizing and keeping names of the universal formula in (+ -),
this simplifies to: 
mvt_gen_ge_ro_TCC2 :  

  |-------
{1}   not_one_element?[(right_open(C))]

Applying right_open_noe 
this simplifies to: 
mvt_gen_ge_ro_TCC2 :  

{-1}  FORALL (c: real): not_one_element?[(right_open(c))]
  |-------
[1]   not_one_element?[(right_open(C))]

Instantiating the top quantifier in -1 with the terms: 
 C,
Q.E.D.


Run time  = 0.02 secs.
Real time = 0.02 secs.

active_corner_certificate.mvt_gen_ge_ro_TCC2 proved in 0.02 real, 0.02 cpu seconds
Rerunning proof of active_corner_certificate.mvt_gen_ge_ro
Installing rewrite rule sets.singleton_rew (all instances)
Installing rewrite rule analysis@lim_of_functions.adherence_fullset (all instances)
Installing rewrite rule reals@sq.sq_abs_neg
Installing rewrite rule reals@sq.sq_abs
Installing rewrite rule reals@sq.sq_1
Installing rewrite rule reals@sq.sq_0
Installing rewrite rule reals@abs_lems.abs_0
Installing rewrite rule reals@abs_lems.abs_nat
Installing rewrite rule sets.member (all instances)
Installing rewrite rule list_props.member (all instances)
mvt_gen_ge_ro :  

  |-------
{1}   FORALL (f: [real -> real], C, c: real, a, b: (right_open(C))):
        (derivable?[(right_open(C))]
             (restrict[real, (right_open(C)), real](f))
          AND
          a >= b AND
           FORALL (x: (right_open(C))):
             deriv[(right_open(C))]
                 (restrict[real, (right_open(C)), real](f))(x)
              >= c)
         IMPLIES f(a) - f(b) >= c * (a - b)

Rerunning step: (THEN (LEMMA "mvt_gen_ge") (SKEEP)
                 (SPREAD (INST -1 "f" "right_open(C)" "c" "a" "b")
                  ((ASSERT)
                   (THEN (LEMMA "right_open_noe")
                    (LEMMA "right_open_connected") (INST -1 "C") (INST -2 "C")
                    (ASSERT)))))
Applying mvt_gen_ge 
this simplifies to: 
mvt_gen_ge_ro :  

{-1}  FORALL (f: [real -> real],
              D:
                {DD: [real -> bool] |
                   connected?[(DD)] AND not_one_element?[(DD)]},
              c: real, a, b: (D)):
        (derivable?[(D)](restrict[real, (D), real](f)) AND
          a >= b AND
           FORALL (x: (D)):
             deriv[(D)](restrict[real, (D), real](f))(x) >= c)
         IMPLIES f(a) - f(b) >= c * (a - b)
  |-------
[1]   FORALL (f: [real -> real], C, c: real, a, b: (right_open(C))):
        (derivable?[(right_open(C))]
             (restrict[real, (right_open(C)), real](f))
          AND
          a >= b AND
           FORALL (x: (right_open(C))):
             deriv[(right_open(C))]
                 (restrict[real, (right_open(C)), real](f))(x)
              >= c)
         IMPLIES f(a) - f(b) >= c * (a - b)

Skolemizing and keeping names of the universal formula in (+ -),
this simplifies to: 
mvt_gen_ge_ro :  

[-1]  FORALL (f: [real -> real],
              D:
                {DD: [real -> bool] |
                   connected?[(DD)] AND not_one_element?[(DD)]},
              c: real, a, b: (D)):
        (derivable?[(D)](restrict[real, (D), real](f)) AND
          a >= b AND
           FORALL (x: (D)):
             deriv[(D)](restrict[real, (D), real](f))(x) >= c)
         IMPLIES f(a) - f(b) >= c * (a - b)
{-2}  derivable?[(right_open(C))](restrict[real, (right_open(C)), real](f))
{-3}  a >= b
{-4}  FORALL (x: (right_open(C))):
        deriv[(right_open(C))](restrict[real, (right_open(C)), real](f))(x)
         >= c
  |-------
{1}   f(a) - f(b) >= c * (a - b)

Instantiating the top quantifier in -1 with the terms: 
 f, right_open(C), c, a, b,
this yields  2 subgoals: 
mvt_gen_ge_ro.1 :  

{-1}  (derivable?[(right_open(C))]
           (restrict[real, (right_open(C)), real](f))
        AND
        a >= b AND
         FORALL (x: (right_open(C))):
           deriv[(right_open(C))]
               (restrict[real, (right_open(C)), real](f))(x)
            >= c)
       IMPLIES f(a) - f(b) >= c * (a - b)
[-2]  derivable?[(right_open(C))](restrict[real, (right_open(C)), real](f))
[-3]  a >= b
[-4]  FORALL (x: (right_open(C))):
        deriv[(right_open(C))](restrict[real, (right_open(C)), real](f))(x)
         >= c
  |-------
[1]   f(a) - f(b) >= c * (a - b)

Simplifying, rewriting, and recording with decision procedures,

This completes the proof of mvt_gen_ge_ro.1.

mvt_gen_ge_ro.2 (TCC):   

[-1]  derivable?[(right_open(C))](restrict[real, (right_open(C)), real](f))
[-2]  a >= b
[-3]  FORALL (x: (right_open(C))):
        deriv[(right_open(C))](restrict[real, (right_open(C)), real](f))(x)
         >= c
  |-------
{1}   connected?[(right_open(C))] AND not_one_element?[(right_open(C))]
[2]   f(a) - f(b) >= c * (a - b)

Applying right_open_noe 
this simplifies to: 
mvt_gen_ge_ro.2 :  

{-1}  FORALL (c: real): not_one_element?[(right_open(c))]
[-2]  derivable?[(right_open(C))](restrict[real, (right_open(C)), real](f))
[-3]  a >= b
[-4]  FORALL (x: (right_open(C))):
        deriv[(right_open(C))](restrict[real, (right_open(C)), real](f))(x)
         >= c
  |-------
[1]   connected?[(right_open(C))] AND not_one_element?[(right_open(C))]
[2]   f(a) - f(b) >= c * (a - b)

Applying right_open_connected 
this simplifies to: 
mvt_gen_ge_ro.2 :  

{-1}  FORALL (c: real): connected?[(right_open(c))]
[-2]  FORALL (c: real): not_one_element?[(right_open(c))]
[-3]  derivable?[(right_open(C))](restrict[real, (right_open(C)), real](f))
[-4]  a >= b
[-5]  FORALL (x: (right_open(C))):
        deriv[(right_open(C))](restrict[real, (right_open(C)), real](f))(x)
         >= c
  |-------
[1]   connected?[(right_open(C))] AND not_one_element?[(right_open(C))]
[2]   f(a) - f(b) >= c * (a - b)

Instantiating the top quantifier in -1 with the terms: 
 C,
this simplifies to: 
mvt_gen_ge_ro.2 :  

{-1}  connected?[(right_open(C))]
[-2]  FORALL (c: real): not_one_element?[(right_open(c))]
[-3]  derivable?[(right_open(C))](restrict[real, (right_open(C)), real](f))
[-4]  a >= b
[-5]  FORALL (x: (right_open(C))):
        deriv[(right_open(C))](restrict[real, (right_open(C)), real](f))(x)
         >= c
  |-------
[1]   connected?[(right_open(C))] AND not_one_element?[(right_open(C))]
[2]   f(a) - f(b) >= c * (a - b)

Instantiating the top quantifier in -2 with the terms: 
 C,
this simplifies to: 
mvt_gen_ge_ro.2 :  

[-1]  connected?[(right_open(C))]
{-2}  not_one_element?[(right_open(C))]
[-3]  derivable?[(right_open(C))](restrict[real, (right_open(C)), real](f))
[-4]  a >= b
[-5]  FORALL (x: (right_open(C))):
        deriv[(right_open(C))](restrict[real, (right_open(C)), real](f))(x)
         >= c
  |-------
[1]   connected?[(right_open(C))] AND not_one_element?[(right_open(C))]
[2]   f(a) - f(b) >= c * (a - b)

Simplifying, rewriting, and recording with decision procedures,

This completes the proof of mvt_gen_ge_ro.2.

Q.E.D.


Run time  = 0.05 secs.
Real time = 0.05 secs.

active_corner_certificate.mvt_gen_ge_ro proved in 0.05 real, 0.05 cpu seconds
Rerunning proof of active_corner_certificate.mvt_gen_le_ro
Installing rewrite rule sets.singleton_rew (all instances)
Installing rewrite rule analysis@lim_of_functions.adherence_fullset (all instances)
Installing rewrite rule reals@sq.sq_abs_neg
Installing rewrite rule reals@sq.sq_abs
Installing rewrite rule reals@sq.sq_1
Installing rewrite rule reals@sq.sq_0
Installing rewrite rule reals@abs_lems.abs_0
Installing rewrite rule reals@abs_lems.abs_nat
Installing rewrite rule sets.member (all instances)
Installing rewrite rule list_props.member (all instances)
mvt_gen_le_ro :  

  |-------
{1}   FORALL (f: [real -> real], C, c: real, a, b: [(right_open(C))]):
        (derivable?[(right_open(C))]
             (restrict[real, (right_open(C)), real](f))
          AND
          a >= b AND
           FORALL (x: [(right_open(C))]):
             deriv[(right_open(C))]
                 (restrict[real, (right_open(C)), real](f))(x)
              <= c)
         IMPLIES f(a) - f(b) <= c * (a - b)

Rerunning step: (THEN (LEMMA "mvt_gen_le") (SKEEP)
                 (SPREAD (INST -1 "f" "right_open(C)" "c" "a" "b")
                  ((ASSERT)
                   (THEN (LEMMA "right_open_noe")
                    (LEMMA "right_open_connected") (INST -1 "C") (INST -2 "C")
                    (ASSERT)))))
Applying mvt_gen_le 
this simplifies to: 
mvt_gen_le_ro :  

{-1}  FORALL (f: [real -> real],
              D:
                {DD: [real -> bool] |
                   connected?[(DD)] AND not_one_element?[(DD)]},
              c: real, a, b: (D)):
        (derivable?[(D)](restrict[real, (D), real](f)) AND
          a >= b AND
           FORALL (x: (D)):
             deriv[(D)](restrict[real, (D), real](f))(x) <= c)
         IMPLIES f(a) - f(b) <= c * (a - b)
  |-------
[1]   FORALL (f: [real -> real], C, c: real, a, b: [(right_open(C))]):
        (derivable?[(right_open(C))]
             (restrict[real, (right_open(C)), real](f))
          AND
          a >= b AND
           FORALL (x: [(right_open(C))]):
             deriv[(right_open(C))]
                 (restrict[real, (right_open(C)), real](f))(x)
              <= c)
         IMPLIES f(a) - f(b) <= c * (a - b)

Skolemizing and keeping names of the universal formula in (+ -),
this simplifies to: 
mvt_gen_le_ro :  

[-1]  FORALL (f: [real -> real],
              D:
                {DD: [real -> bool] |
                   connected?[(DD)] AND not_one_element?[(DD)]},
              c: real, a, b: (D)):
        (derivable?[(D)](restrict[real, (D), real](f)) AND
          a >= b AND
           FORALL (x: (D)):
             deriv[(D)](restrict[real, (D), real](f))(x) <= c)
         IMPLIES f(a) - f(b) <= c * (a - b)
{-2}  derivable?[(right_open(C))](restrict[real, (right_open(C)), real](f))
{-3}  a >= b
{-4}  FORALL (x: [(right_open(C))]):
        deriv[(right_open(C))](restrict[real, (right_open(C)), real](f))(x)
         <= c
  |-------
{1}   f(a) - f(b) <= c * (a - b)

Instantiating the top quantifier in -1 with the terms: 
 f, right_open(C), c, a, b,
this yields  2 subgoals: 
mvt_gen_le_ro.1 :  

{-1}  (derivable?[(right_open(C))]
           (restrict[real, (right_open(C)), real](f))
        AND
        a >= b AND
         FORALL (x: (right_open(C))):
           deriv[(right_open(C))]
               (restrict[real, (right_open(C)), real](f))(x)
            <= c)
       IMPLIES f(a) - f(b) <= c * (a - b)
[-2]  derivable?[(right_open(C))](restrict[real, (right_open(C)), real](f))
[-3]  a >= b
[-4]  FORALL (x: [(right_open(C))]):
        deriv[(right_open(C))](restrict[real, (right_open(C)), real](f))(x)
         <= c
  |-------
[1]   f(a) - f(b) <= c * (a - b)

Simplifying, rewriting, and recording with decision procedures,

This completes the proof of mvt_gen_le_ro.1.

mvt_gen_le_ro.2 (TCC):   

[-1]  derivable?[(right_open(C))](restrict[real, (right_open(C)), real](f))
[-2]  a >= b
[-3]  FORALL (x: [(right_open(C))]):
        deriv[(right_open(C))](restrict[real, (right_open(C)), real](f))(x)
         <= c
  |-------
{1}   connected?[(right_open(C))] AND not_one_element?[(right_open(C))]
[2]   f(a) - f(b) <= c * (a - b)

Applying right_open_noe 
this simplifies to: 
mvt_gen_le_ro.2 :  

{-1}  FORALL (c: real): not_one_element?[(right_open(c))]
[-2]  derivable?[(right_open(C))](restrict[real, (right_open(C)), real](f))
[-3]  a >= b
[-4]  FORALL (x: [(right_open(C))]):
        deriv[(right_open(C))](restrict[real, (right_open(C)), real](f))(x)
         <= c
  |-------
[1]   connected?[(right_open(C))] AND not_one_element?[(right_open(C))]
[2]   f(a) - f(b) <= c * (a - b)

Applying right_open_connected 
this simplifies to: 
mvt_gen_le_ro.2 :  

{-1}  FORALL (c: real): connected?[(right_open(c))]
[-2]  FORALL (c: real): not_one_element?[(right_open(c))]
[-3]  derivable?[(right_open(C))](restrict[real, (right_open(C)), real](f))
[-4]  a >= b
[-5]  FORALL (x: [(right_open(C))]):
        deriv[(right_open(C))](restrict[real, (right_open(C)), real](f))(x)
         <= c
  |-------
[1]   connected?[(right_open(C))] AND not_one_element?[(right_open(C))]
[2]   f(a) - f(b) <= c * (a - b)

Instantiating the top quantifier in -1 with the terms: 
 C,
this simplifies to: 
mvt_gen_le_ro.2 :  

{-1}  connected?[(right_open(C))]
[-2]  FORALL (c: real): not_one_element?[(right_open(c))]
[-3]  derivable?[(right_open(C))](restrict[real, (right_open(C)), real](f))
[-4]  a >= b
[-5]  FORALL (x: [(right_open(C))]):
        deriv[(right_open(C))](restrict[real, (right_open(C)), real](f))(x)
         <= c
  |-------
[1]   connected?[(right_open(C))] AND not_one_element?[(right_open(C))]
[2]   f(a) - f(b) <= c * (a - b)

Instantiating the top quantifier in -2 with the terms: 
 C,
this simplifies to: 
mvt_gen_le_ro.2 :  

[-1]  connected?[(right_open(C))]
{-2}  not_one_element?[(right_open(C))]
[-3]  derivable?[(right_open(C))](restrict[real, (right_open(C)), real](f))
[-4]  a >= b
[-5]  FORALL (x: [(right_open(C))]):
        deriv[(right_open(C))](restrict[real, (right_open(C)), real](f))(x)
         <= c
  |-------
[1]   connected?[(right_open(C))] AND not_one_element?[(right_open(C))]
[2]   f(a) - f(b) <= c * (a - b)

Simplifying, rewriting, and recording with decision procedures,

This completes the proof of mvt_gen_le_ro.2.

Q.E.D.


Run time  = 0.06 secs.
Real time = 0.06 secs.

active_corner_certificate.mvt_gen_le_ro proved in 0.06 real, 0.06 cpu seconds
Rerunning proof of active_corner_certificate.mvt_gen_ge_ci_TCC1
Installing rewrite rule sets.singleton_rew (all instances)
Installing rewrite rule analysis@lim_of_functions.adherence_fullset (all instances)
Installing rewrite rule reals@sq.sq_abs_neg
Installing rewrite rule reals@sq.sq_abs
Installing rewrite rule reals@sq.sq_1
Installing rewrite rule reals@sq.sq_0
Installing rewrite rule reals@abs_lems.abs_0
Installing rewrite rule reals@abs_lems.abs_nat
Installing rewrite rule sets.member (all instances)
Installing rewrite rule list_props.member (all instances)
mvt_gen_ge_ci_TCC1 :  

  |-------
{1}   FORALL (d1, d2: real, a, b: (ci(d1, d2))):
        d1 < d2 IMPLIES deriv_domain?[(ci(d1, d2))]

Rerunning step: (THEN (SKEEP) (LEMMA "ci_dd") (INST -1 "d1" "d2") (ASSERT)
                 (GRIND))
Skolemizing and keeping names of the universal formula in (+ -),
this simplifies to: 
mvt_gen_ge_ci_TCC1 :  

{-1}  d1 < d2
  |-------
{1}   deriv_domain?[(ci(d1, d2))]

Applying ci_dd 
this simplifies to: 
mvt_gen_ge_ci_TCC1 :  

{-1}  FORALL (d1, d2: real): d1 /= d2 IMPLIES deriv_domain?[(ci(d1, d2))]
[-2]  d1 < d2
  |-------
[1]   deriv_domain?[(ci(d1, d2))]

Instantiating the top quantifier in -1 with the terms: 
 d1, d2,
this simplifies to: 
mvt_gen_ge_ci_TCC1 :  

{-1}  d1 /= d2 IMPLIES deriv_domain?[(ci(d1, d2))]
[-2]  d1 < d2
  |-------
[1]   deriv_domain?[(ci(d1, d2))]

Simplifying, rewriting, and recording with decision procedures,
Q.E.D.


Run time  = 0.02 secs.
Real time = 0.02 secs.

active_corner_certificate.mvt_gen_ge_ci_TCC1 proved in 0.02 real, 0.02 cpu seconds
Rerunning proof of active_corner_certificate.mvt_gen_ge_ci_TCC2
Installing rewrite rule sets.singleton_rew (all instances)
Installing rewrite rule analysis@lim_of_functions.adherence_fullset (all instances)
Installing rewrite rule reals@sq.sq_abs_neg
Installing rewrite rule reals@sq.sq_abs
Installing rewrite rule reals@sq.sq_1
Installing rewrite rule reals@sq.sq_0
Installing rewrite rule reals@abs_lems.abs_0
Installing rewrite rule reals@abs_lems.abs_nat
Installing rewrite rule sets.member (all instances)
Installing rewrite rule list_props.member (all instances)
mvt_gen_ge_ci_TCC2 :  

  |-------
{1}   FORALL (d1, d2: real, a, b: (ci(d1, d2))):
        d1 < d2 IMPLIES not_one_element?[(ci(d1, d2))]

Rerunning step: (THEN (SKEEP) (LEMMA "ci_noe") (INST -1 "d1" "d2") (ASSERT)
                 (GRIND))
Skolemizing and keeping names of the universal formula in (+ -),
this simplifies to: 
mvt_gen_ge_ci_TCC2 :  

{-1}  d1 < d2
  |-------
{1}   not_one_element?[(ci(d1, d2))]

Applying ci_noe 
this simplifies to: 
mvt_gen_ge_ci_TCC2 :  

{-1}  FORALL (d1, d2: real): d1 /= d2 IMPLIES not_one_element?[(ci(d1, d2))]
[-2]  d1 < d2
  |-------
[1]   not_one_element?[(ci(d1, d2))]

Instantiating the top quantifier in -1 with the terms: 
 d1, d2,
this simplifies to: 
mvt_gen_ge_ci_TCC2 :  

{-1}  d1 /= d2 IMPLIES not_one_element?[(ci(d1, d2))]
[-2]  d1 < d2
  |-------
[1]   not_one_element?[(ci(d1, d2))]

Simplifying, rewriting, and recording with decision procedures,
Q.E.D.


Run time  = 0.02 secs.
Real time = 0.02 secs.

active_corner_certificate.mvt_gen_ge_ci_TCC2 proved in 0.02 real, 0.02 cpu seconds
Rerunning proof of active_corner_certificate.mvt_gen_ge_ci
Installing rewrite rule sets.singleton_rew (all instances)
Installing rewrite rule analysis@lim_of_functions.adherence_fullset (all instances)
Installing rewrite rule reals@sq.sq_abs_neg
Installing rewrite rule reals@sq.sq_abs
Installing rewrite rule reals@sq.sq_1
Installing rewrite rule reals@sq.sq_0
Installing rewrite rule reals@abs_lems.abs_0
Installing rewrite rule reals@abs_lems.abs_nat
Installing rewrite rule sets.member (all instances)
Installing rewrite rule list_props.member (all instances)
mvt_gen_ge_ci :  

  |-------
{1}   FORALL (f: [real -> real], d1, d2, c: real, a, b: (ci(d1, d2))):
        (d1 < d2 AND
          derivable?[(ci(d1, d2))](restrict[real, (ci(d1, d2)), real](f))
           AND
           a >= b AND
            FORALL (x: (ci(d1, d2))):
              deriv[(ci(d1, d2))](restrict[real, (ci(d1, d2)), real](f))(x)
               >= c)
         IMPLIES f(a) - f(b) >= c * (a - b)

Rerunning step: (THEN (LEMMA "mvt_gen_ge") (SKEEP)
                 (SPREAD (INST -1 "f" "ci(d1,d2)" "c" "a" "b")
                  ((ASSERT)
                   (THEN (LEMMA "ci_noe") (LEMMA " ci_connected")
                    (INST -1 "d1" "d2") (INST -2 "d1" "d2") (ASSERT)))))
Applying mvt_gen_ge 
this simplifies to: 
mvt_gen_ge_ci :  

{-1}  FORALL (f: [real -> real],
              D:
                {DD: [real -> bool] |
                   connected?[(DD)] AND not_one_element?[(DD)]},
              c: real, a, b: (D)):
        (derivable?[(D)](restrict[real, (D), real](f)) AND
          a >= b AND
           FORALL (x: (D)):
             deriv[(D)](restrict[real, (D), real](f))(x) >= c)
         IMPLIES f(a) - f(b) >= c * (a - b)
  |-------
[1]   FORALL (f: [real -> real], d1, d2, c: real, a, b: (ci(d1, d2))):
        (d1 < d2 AND
          derivable?[(ci(d1, d2))](restrict[real, (ci(d1, d2)), real](f))
           AND
           a >= b AND
            FORALL (x: (ci(d1, d2))):
              deriv[(ci(d1, d2))](restrict[real, (ci(d1, d2)), real](f))(x)
               >= c)
         IMPLIES f(a) - f(b) >= c * (a - b)

Skolemizing and keeping names of the universal formula in (+ -),
this simplifies to: 
mvt_gen_ge_ci :  

[-1]  FORALL (f: [real -> real],
              D:
                {DD: [real -> bool] |
                   connected?[(DD)] AND not_one_element?[(DD)]},
              c: real, a, b: (D)):
        (derivable?[(D)](restrict[real, (D), real](f)) AND
          a >= b AND
           FORALL (x: (D)):
             deriv[(D)](restrict[real, (D), real](f))(x) >= c)
         IMPLIES f(a) - f(b) >= c * (a - b)
{-2}  d1 < d2
{-3}  derivable?[(ci(d1, d2))](restrict[real, (ci(d1, d2)), real](f))
{-4}  a >= b
{-5}  FORALL (x: (ci(d1, d2))):
        deriv[(ci(d1, d2))](restrict[real, (ci(d1, d2)), real](f))(x) >= c
  |-------
{1}   f(a) - f(b) >= c * (a - b)

Instantiating the top quantifier in -1 with the terms: 
 f, ci(d1,d2), c, a, b,
this yields  2 subgoals: 
mvt_gen_ge_ci.1 :  

{-1}  (derivable?[(ci(d1, d2))](restrict[real, (ci(d1, d2)), real](f)) AND
        a >= b AND
         FORALL (x: (ci(d1, d2))):
           deriv[(ci(d1, d2))](restrict[real, (ci(d1, d2)), real](f))(x) >=
            c)
       IMPLIES f(a) - f(b) >= c * (a - b)
[-2]  d1 < d2
[-3]  derivable?[(ci(d1, d2))](restrict[real, (ci(d1, d2)), real](f))
[-4]  a >= b
[-5]  FORALL (x: (ci(d1, d2))):
        deriv[(ci(d1, d2))](restrict[real, (ci(d1, d2)), real](f))(x) >= c
  |-------
[1]   f(a) - f(b) >= c * (a - b)

Simplifying, rewriting, and recording with decision procedures,

This completes the proof of mvt_gen_ge_ci.1.

mvt_gen_ge_ci.2 (TCC):   

[-1]  d1 < d2
[-2]  derivable?[(ci(d1, d2))](restrict[real, (ci(d1, d2)), real](f))
[-3]  a >= b
[-4]  FORALL (x: (ci(d1, d2))):
        deriv[(ci(d1, d2))](restrict[real, (ci(d1, d2)), real](f))(x) >= c
  |-------
{1}   connected?[(ci(d1, d2))] AND not_one_element?[(ci(d1, d2))]
[2]   f(a) - f(b) >= c * (a - b)

Applying ci_noe 
this simplifies to: 
mvt_gen_ge_ci.2 :  

{-1}  FORALL (d1, d2: real): d1 /= d2 IMPLIES not_one_element?[(ci(d1, d2))]
[-2]  d1 < d2
[-3]  derivable?[(ci(d1, d2))](restrict[real, (ci(d1, d2)), real](f))
[-4]  a >= b
[-5]  FORALL (x: (ci(d1, d2))):
        deriv[(ci(d1, d2))](restrict[real, (ci(d1, d2)), real](f))(x) >= c
  |-------
[1]   connected?[(ci(d1, d2))] AND not_one_element?[(ci(d1, d2))]
[2]   f(a) - f(b) >= c * (a - b)

Applying ci_connected 
this simplifies to: 
mvt_gen_ge_ci.2 :  

{-1}  FORALL (d1, d2: real): d1 /= d2 IMPLIES connected?[(ci(d1, d2))]
[-2]  FORALL (d1, d2: real): d1 /= d2 IMPLIES not_one_element?[(ci(d1, d2))]
[-3]  d1 < d2
[-4]  derivable?[(ci(d1, d2))](restrict[real, (ci(d1, d2)), real](f))
[-5]  a >= b
[-6]  FORALL (x: (ci(d1, d2))):
        deriv[(ci(d1, d2))](restrict[real, (ci(d1, d2)), real](f))(x) >= c
  |-------
[1]   connected?[(ci(d1, d2))] AND not_one_element?[(ci(d1, d2))]
[2]   f(a) - f(b) >= c * (a - b)

Instantiating the top quantifier in -1 with the terms: 
 d1, d2,
this simplifies to: 
mvt_gen_ge_ci.2 :  

{-1}  d1 /= d2 IMPLIES connected?[(ci(d1, d2))]
[-2]  FORALL (d1, d2: real): d1 /= d2 IMPLIES not_one_element?[(ci(d1, d2))]
[-3]  d1 < d2
[-4]  derivable?[(ci(d1, d2))](restrict[real, (ci(d1, d2)), real](f))
[-5]  a >= b
[-6]  FORALL (x: (ci(d1, d2))):
        deriv[(ci(d1, d2))](restrict[real, (ci(d1, d2)), real](f))(x) >= c
  |-------
[1]   connected?[(ci(d1, d2))] AND not_one_element?[(ci(d1, d2))]
[2]   f(a) - f(b) >= c * (a - b)

Instantiating the top quantifier in -2 with the terms: 
 d1, d2,
this simplifies to: 
mvt_gen_ge_ci.2 :  

[-1]  d1 /= d2 IMPLIES connected?[(ci(d1, d2))]
{-2}  d1 /= d2 IMPLIES not_one_element?[(ci(d1, d2))]
[-3]  d1 < d2
[-4]  derivable?[(ci(d1, d2))](restrict[real, (ci(d1, d2)), real](f))
[-5]  a >= b
[-6]  FORALL (x: (ci(d1, d2))):
        deriv[(ci(d1, d2))](restrict[real, (ci(d1, d2)), real](f))(x) >= c
  |-------
[1]   connected?[(ci(d1, d2))] AND not_one_element?[(ci(d1, d2))]
[2]   f(a) - f(b) >= c * (a - b)

Simplifying, rewriting, and recording with decision procedures,

This completes the proof of mvt_gen_ge_ci.2.

Q.E.D.


Run time  = 0.06 secs.
Real time = 0.06 secs.

active_corner_certificate.mvt_gen_ge_ci proved in 0.06 real, 0.06 cpu seconds
Rerunning proof of active_corner_certificate.mvt_gen_le_ci
Installing rewrite rule sets.singleton_rew (all instances)
Installing rewrite rule analysis@lim_of_functions.adherence_fullset (all instances)
Installing rewrite rule reals@sq.sq_abs_neg
Installing rewrite rule reals@sq.sq_abs
Installing rewrite rule reals@sq.sq_1
Installing rewrite rule reals@sq.sq_0
Installing rewrite rule reals@abs_lems.abs_0
Installing rewrite rule reals@abs_lems.abs_nat
Installing rewrite rule sets.member (all instances)
Installing rewrite rule list_props.member (all instances)
mvt_gen_le_ci :  

  |-------
{1}   FORALL (f: [real -> real], d1, d2, c: real, a, b: (ci(d1, d2))):
        (d1 < d2 AND
          derivable?[(ci(d1, d2))](restrict[real, (ci(d1, d2)), real](f))
           AND
           a >= b AND
            FORALL (x: (ci(d1, d2))):
              deriv[(ci(d1, d2))](restrict[real, (ci(d1, d2)), real](f))(x)
               <= c)
         IMPLIES f(a) - f(b) <= c * (a - b)

Rerunning step: (THEN (LEMMA "mvt_gen_le") (SKEEP)
                 (SPREAD (INST -1 "f" "ci(d1,d2)" "c" "a" "b")
                  ((ASSERT)
                   (THEN (LEMMA "ci_noe") (LEMMA " ci_connected")
                    (INST -1 "d1" "d2") (INST -2 "d1" "d2") (ASSERT)))))
Applying mvt_gen_le 
this simplifies to: 
mvt_gen_le_ci :  

{-1}  FORALL (f: [real -> real],
              D:
                {DD: [real -> bool] |
                   connected?[(DD)] AND not_one_element?[(DD)]},
              c: real, a, b: (D)):
        (derivable?[(D)](restrict[real, (D), real](f)) AND
          a >= b AND
           FORALL (x: (D)):
             deriv[(D)](restrict[real, (D), real](f))(x) <= c)
         IMPLIES f(a) - f(b) <= c * (a - b)
  |-------
[1]   FORALL (f: [real -> real], d1, d2, c: real, a, b: (ci(d1, d2))):
        (d1 < d2 AND
          derivable?[(ci(d1, d2))](restrict[real, (ci(d1, d2)), real](f))
           AND
           a >= b AND
            FORALL (x: (ci(d1, d2))):
              deriv[(ci(d1, d2))](restrict[real, (ci(d1, d2)), real](f))(x)
               <= c)
         IMPLIES f(a) - f(b) <= c * (a - b)

Skolemizing and keeping names of the universal formula in (+ -),
this simplifies to: 
mvt_gen_le_ci :  

[-1]  FORALL (f: [real -> real],
              D:
                {DD: [real -> bool] |
                   connected?[(DD)] AND not_one_element?[(DD)]},
              c: real, a, b: (D)):
        (derivable?[(D)](restrict[real, (D), real](f)) AND
          a >= b AND
           FORALL (x: (D)):
             deriv[(D)](restrict[real, (D), real](f))(x) <= c)
         IMPLIES f(a) - f(b) <= c * (a - b)
{-2}  d1 < d2
{-3}  derivable?[(ci(d1, d2))](restrict[real, (ci(d1, d2)), real](f))
{-4}  a >= b
{-5}  FORALL (x: (ci(d1, d2))):
        deriv[(ci(d1, d2))](restrict[real, (ci(d1, d2)), real](f))(x) <= c
  |-------
{1}   f(a) - f(b) <= c * (a - b)

Instantiating the top quantifier in -1 with the terms: 
 f, ci(d1,d2), c, a, b,
this yields  2 subgoals: 
mvt_gen_le_ci.1 :  

{-1}  (derivable?[(ci(d1, d2))](restrict[real, (ci(d1, d2)), real](f)) AND
        a >= b AND
         FORALL (x: (ci(d1, d2))):
           deriv[(ci(d1, d2))](restrict[real, (ci(d1, d2)), real](f))(x) <=
            c)
       IMPLIES f(a) - f(b) <= c * (a - b)
[-2]  d1 < d2
[-3]  derivable?[(ci(d1, d2))](restrict[real, (ci(d1, d2)), real](f))
[-4]  a >= b
[-5]  FORALL (x: (ci(d1, d2))):
        deriv[(ci(d1, d2))](restrict[real, (ci(d1, d2)), real](f))(x) <= c
  |-------
[1]   f(a) - f(b) <= c * (a - b)

Simplifying, rewriting, and recording with decision procedures,

This completes the proof of mvt_gen_le_ci.1.

mvt_gen_le_ci.2 (TCC):   

[-1]  d1 < d2
[-2]  derivable?[(ci(d1, d2))](restrict[real, (ci(d1, d2)), real](f))
[-3]  a >= b
[-4]  FORALL (x: (ci(d1, d2))):
        deriv[(ci(d1, d2))](restrict[real, (ci(d1, d2)), real](f))(x) <= c
  |-------
{1}   connected?[(ci(d1, d2))] AND not_one_element?[(ci(d1, d2))]
[2]   f(a) - f(b) <= c * (a - b)

Applying ci_noe 
this simplifies to: 
mvt_gen_le_ci.2 :  

{-1}  FORALL (d1, d2: real): d1 /= d2 IMPLIES not_one_element?[(ci(d1, d2))]
[-2]  d1 < d2
[-3]  derivable?[(ci(d1, d2))](restrict[real, (ci(d1, d2)), real](f))
[-4]  a >= b
[-5]  FORALL (x: (ci(d1, d2))):
        deriv[(ci(d1, d2))](restrict[real, (ci(d1, d2)), real](f))(x) <= c
  |-------
[1]   connected?[(ci(d1, d2))] AND not_one_element?[(ci(d1, d2))]
[2]   f(a) - f(b) <= c * (a - b)

Applying ci_connected 
this simplifies to: 
mvt_gen_le_ci.2 :  

{-1}  FORALL (d1, d2: real): d1 /= d2 IMPLIES connected?[(ci(d1, d2))]
[-2]  FORALL (d1, d2: real): d1 /= d2 IMPLIES not_one_element?[(ci(d1, d2))]
[-3]  d1 < d2
[-4]  derivable?[(ci(d1, d2))](restrict[real, (ci(d1, d2)), real](f))
[-5]  a >= b
[-6]  FORALL (x: (ci(d1, d2))):
        deriv[(ci(d1, d2))](restrict[real, (ci(d1, d2)), real](f))(x) <= c
  |-------
[1]   connected?[(ci(d1, d2))] AND not_one_element?[(ci(d1, d2))]
[2]   f(a) - f(b) <= c * (a - b)

Instantiating the top quantifier in -1 with the terms: 
 d1, d2,
this simplifies to: 
mvt_gen_le_ci.2 :  

{-1}  d1 /= d2 IMPLIES connected?[(ci(d1, d2))]
[-2]  FORALL (d1, d2: real): d1 /= d2 IMPLIES not_one_element?[(ci(d1, d2))]
[-3]  d1 < d2
[-4]  derivable?[(ci(d1, d2))](restrict[real, (ci(d1, d2)), real](f))
[-5]  a >= b
[-6]  FORALL (x: (ci(d1, d2))):
        deriv[(ci(d1, d2))](restrict[real, (ci(d1, d2)), real](f))(x) <= c
  |-------
[1]   connected?[(ci(d1, d2))] AND not_one_element?[(ci(d1, d2))]
[2]   f(a) - f(b) <= c * (a - b)

Instantiating the top quantifier in -2 with the terms: 
 d1, d2,
this simplifies to: 
mvt_gen_le_ci.2 :  

[-1]  d1 /= d2 IMPLIES connected?[(ci(d1, d2))]
{-2}  d1 /= d2 IMPLIES not_one_element?[(ci(d1, d2))]
[-3]  d1 < d2
[-4]  derivable?[(ci(d1, d2))](restrict[real, (ci(d1, d2)), real](f))
[-5]  a >= b
[-6]  FORALL (x: (ci(d1, d2))):
        deriv[(ci(d1, d2))](restrict[real, (ci(d1, d2)), real](f))(x) <= c
  |-------
[1]   connected?[(ci(d1, d2))] AND not_one_element?[(ci(d1, d2))]
[2]   f(a) - f(b) <= c * (a - b)

Simplifying, rewriting, and recording with decision procedures,

This completes the proof of mvt_gen_le_ci.2.

Q.E.D.


Run time  = 0.07 secs.
Real time = 0.07 secs.

active_corner_certificate.mvt_gen_le_ci proved in 0.07 real, 0.07 cpu seconds
Rerunning proof of active_corner_certificate.mvt_gen_ge_real_TCC1
Installing rewrite rule sets.singleton_rew (all instances)
Installing rewrite rule analysis@lim_of_functions.adherence_fullset (all instances)
Installing rewrite rule reals@sq.sq_abs_neg
Installing rewrite rule reals@sq.sq_abs
Installing rewrite rule reals@sq.sq_1
Installing rewrite rule reals@sq.sq_0
Installing rewrite rule reals@abs_lems.abs_0
Installing rewrite rule reals@abs_lems.abs_nat
Installing rewrite rule sets.member (all instances)
Installing rewrite rule list_props.member (all instances)
mvt_gen_ge_real_TCC1 :  

  |-------
{1}   deriv_domain?[real]

Rerunning step: (THEN (ASSERT) (GRIND))
Simplifying, rewriting, and recording with decision procedures,
this simplifies to: 
mvt_gen_ge_real_TCC1 :  

  |-------
[1]   deriv_domain?[real]

Trying repeated skolemization, instantiation, and if-lifting,
this simplifies to: 
mvt_gen_ge_real_TCC1 :  

{-1}  e!1 >= 0
{-2}  e!1 > 0
{-3}  real_pred(x!1)
  |-------

Postponing mvt_gen_ge_real_TCC1.

mvt_gen_ge_real_TCC1 :  

{-1}  e!1 >= 0
{-2}  e!1 > 0
{-3}  real_pred(x!1)
  |-------

***Warning: mvt_gen_ge_real_TCC1 has fewer subproofs (0) than subgoals (1)
No change on: (SKIP)
mvt_gen_ge_real_TCC1 :  

{-1}  e!1 >= 0
{-2}  e!1 > 0
{-3}  real_pred(x!1)
  |-------

Postponing mvt_gen_ge_real_TCC1.

mvt_gen_ge_real_TCC1 :  

{-1}  e!1 >= 0
{-2}  e!1 > 0
{-3}  real_pred(x!1)
  |-------

Postponing mvt_gen_ge_real_TCC1.

mvt_gen_ge_real_TCC1 :  

{-1}  e!1 >= 0
{-2}  e!1 > 0
{-3}  real_pred(x!1)
  |-------


Run time  = 0.04 secs.
Real time = 0.04 secs.

active_corner_certificate.mvt_gen_ge_real_TCC1 unproved in 0.04 real, 0.04 cpu seconds
Rerunning proof of active_corner_certificate.mvt_gen_ge_real_TCC2
Installing rewrite rule sets.singleton_rew (all instances)
Installing rewrite rule analysis@lim_of_functions.adherence_fullset (all instances)
Installing rewrite rule reals@sq.sq_abs_neg
Installing rewrite rule reals@sq.sq_abs
Installing rewrite rule reals@sq.sq_1
Installing rewrite rule reals@sq.sq_0
Installing rewrite rule reals@abs_lems.abs_0
Installing rewrite rule reals@abs_lems.abs_nat
Installing rewrite rule sets.member (all instances)
Installing rewrite rule list_props.member (all instances)
mvt_gen_ge_real_TCC2 :  

  |-------
{1}   not_one_element?[real]

Rerunning step: (THEN (ASSERT) (GRIND))
Simplifying, rewriting, and recording with decision procedures,
this simplifies to: 
mvt_gen_ge_real_TCC2 :  

  |-------
[1]   not_one_element?[real]

Trying repeated skolemization, instantiation, and if-lifting,
this simplifies to: 
mvt_gen_ge_real_TCC2 :  

{-1}  real_pred(x!1)
  |-------

Postponing mvt_gen_ge_real_TCC2.

mvt_gen_ge_real_TCC2 :  

{-1}  real_pred(x!1)
  |-------

***Warning: mvt_gen_ge_real_TCC2 has fewer subproofs (0) than subgoals (1)
No change on: (SKIP)
mvt_gen_ge_real_TCC2 :  

{-1}  real_pred(x!1)
  |-------

Postponing mvt_gen_ge_real_TCC2.

mvt_gen_ge_real_TCC2 :  

{-1}  real_pred(x!1)
  |-------

Postponing mvt_gen_ge_real_TCC2.

mvt_gen_ge_real_TCC2 :  

{-1}  real_pred(x!1)
  |-------


Run time  = 0.02 secs.
Real time = 0.02 secs.

active_corner_certificate.mvt_gen_ge_real_TCC2 unproved in 0.02 real, 0.02 cpu seconds
Rerunning proof of active_corner_certificate.mvt_gen_ge_real
Installing rewrite rule sets.singleton_rew (all instances)
Installing rewrite rule analysis@lim_of_functions.adherence_fullset (all instances)
Installing rewrite rule reals@sq.sq_abs_neg
Installing rewrite rule reals@sq.sq_abs
Installing rewrite rule reals@sq.sq_1
Installing rewrite rule reals@sq.sq_0
Installing rewrite rule reals@abs_lems.abs_0
Installing rewrite rule reals@abs_lems.abs_nat
Installing rewrite rule sets.member (all instances)
Installing rewrite rule list_props.member (all instances)
mvt_gen_ge_real :  

  |-------
{1}   FORALL (f: [real -> real], c: real, a, b: real):
        (derivable?[real](f) AND
          a >= b AND FORALL (x: real): deriv[real](f)(x) >= c)
         IMPLIES f(a) - f(b) >= c * (a - b)

Rerunning step: (SPREAD (LEMMA "mean_value[real]")
                 ((THEN (SKEEP) (INST -1 "b" "a" "f") (ASSERT) (SKEEP)
                   (INST -6 "c!1") (EXPAND "deriv" -6) (ASSERT)
                   (MULT-BY -6 "a-b") (ASSERT))
                  (THEN (ASSERT) (LEMMA "connected_real") (PROPAX))))
Applying mean_value[real] 
this yields  3 subgoals: 
mvt_gen_ge_real.1 :  

{-1}  FORALL (a, b: real, f: [real -> real]):
        derivable?(f) AND a < b IMPLIES
         EXISTS (c: real):
           a < c AND c < b AND deriv(f, c) * (b - a) = f(b) - f(a)
  |-------
[1]   FORALL (f: [real -> real], c: real, a, b: real):
        (derivable?[real](f) AND
          a >= b AND FORALL (x: real): deriv[real](f)(x) >= c)
         IMPLIES f(a) - f(b) >= c * (a - b)

Skolemizing and keeping names of the universal formula in (+ -),
this simplifies to: 
mvt_gen_ge_real.1 :  

[-1]  FORALL (a, b: real, f: [real -> real]):
        derivable?(f) AND a < b IMPLIES
         EXISTS (c: real):
           a < c AND c < b AND deriv(f, c) * (b - a) = f(b) - f(a)
{-2}  derivable?[real](f)
{-3}  a >= b
{-4}  FORALL (x: real): deriv[real](f)(x) >= c
  |-------
{1}   f(a) - f(b) >= c * (a - b)

Instantiating the top quantifier in -1 with the terms: 
 b, a, f,
this simplifies to: 
mvt_gen_ge_real.1 :  

{-1}  derivable?(f) AND b < a IMPLIES
       EXISTS (c: real):
         b < c AND c < a AND deriv(f, c) * (a - b) = f(a) - f(b)
[-2]  derivable?[real](f)
[-3]  a >= b
[-4]  FORALL (x: real): deriv[real](f)(x) >= c
  |-------
[1]   f(a) - f(b) >= c * (a - b)

Simplifying, rewriting, and recording with decision procedures,
this simplifies to: 
mvt_gen_ge_real.1 :  

{-1}  EXISTS (c: real):
        b < c AND c < a AND deriv(f, c) * a - deriv(f, c) * b = f(a) - f(b)
[-2]  derivable?[real](f)
[-3]  a >= b
[-4]  FORALL (x: real): deriv[real](f)(x) >= c
  |-------
{1}   f(a) - f(b) >= a * c - b * c

Skolemizing and keeping names of the universal formula in (+ -),
this simplifies to: 
mvt_gen_ge_real.1 :  

{-1}  b < c!1
{-2}  c!1 < a
{-3}  deriv(f, c!1) * a - deriv(f, c!1) * b = f(a) - f(b)
[-4]  derivable?[real](f)
[-5]  a >= b
[-6]  FORALL (x: real): deriv[real](f)(x) >= c
  |-------
[1]   f(a) - f(b) >= a * c - b * c

Instantiating the top quantifier in -6 with the terms: 
 c!1,
this simplifies to: 
mvt_gen_ge_real.1 :  

[-1]  b < c!1
[-2]  c!1 < a
[-3]  deriv(f, c!1) * a - deriv(f, c!1) * b = f(a) - f(b)
[-4]  derivable?[real](f)
[-5]  a >= b
{-6}  deriv[real](f)(c!1) >= c
  |-------
[1]   f(a) - f(b) >= a * c - b * c

Expanding the definition of deriv,
this simplifies to: 
mvt_gen_ge_real.1 :  

[-1]  b < c!1
[-2]  c!1 < a
[-3]  deriv(f, c!1) * a - deriv(f, c!1) * b = f(a) - f(b)
[-4]  derivable?[real](f)
[-5]  a >= b
{-6}  deriv[real](f, c!1) >= c
  |-------
[1]   f(a) - f(b) >= a * c - b * c

Simplifying, rewriting, and recording with decision procedures,
this simplifies to: 
mvt_gen_ge_real.1 :  

[-1]  b < c!1
[-2]  c!1 < a
[-3]  deriv(f, c!1) * a - deriv(f, c!1) * b = f(a) - f(b)
[-4]  derivable?[real](f)
[-5]  a >= b
[-6]  deriv[real](f, c!1) >= c
  |-------
[1]   f(a) - f(b) >= a * c - b * c

Multiplying both sides of selected formulas by given term,
this simplifies to: 
mvt_gen_ge_real.1 :  

{-1}  deriv[real](f, c!1) * (a - b) >= c * (a - b)
[-2]  b < c!1
[-3]  c!1 < a
[-4]  deriv(f, c!1) * a - deriv(f, c!1) * b = f(a) - f(b)
[-5]  derivable?[real](f)
[-6]  a >= b
  |-------
[1]   f(a) - f(b) >= a * c - b * c

Simplifying, rewriting, and recording with decision procedures,

This completes the proof of mvt_gen_ge_real.1.

mvt_gen_ge_real.2T (TCC):   

  |-------
{1}   not_one_element?[real]
[2]   FORALL (f: [real -> real], c: real, a, b: real):
        (derivable?[real](f) AND
          a >= b AND FORALL (x: real): deriv[real](f)(x) >= c)
         IMPLIES f(a) - f(b) >= c * (a - b)

Simplifying, rewriting, and recording with decision procedures,
this simplifies to: 
mvt_gen_ge_real.2T :  

  |-------
[1]   not_one_element?[real]
{2}   FORALL (f: [real -> real], c: real, a, b: real):
        (derivable?[real](f) AND
          a >= b AND FORALL (x: real): deriv[real](f)(x) >= c)
         IMPLIES f(a) - f(b) >= a * c - b * c

Applying connected_real 
this simplifies to: 
mvt_gen_ge_real.2T :  

{-1}  connected?[real]
  |-------
[1]   not_one_element?[real]
[2]   FORALL (f: [real -> real], c: real, a, b: real):
        (derivable?[real](f) AND
          a >= b AND FORALL (x: real): deriv[real](f)(x) >= c)
         IMPLIES f(a) - f(b) >= a * c - b * c

No change on: (PROPAX)
mvt_gen_ge_real.2T :  

{-1}  connected?[real]
  |-------
[1]   not_one_element?[real]
[2]   FORALL (f: [real -> real], c: real, a, b: real):
        (derivable?[real](f) AND
          a >= b AND FORALL (x: real): deriv[real](f)(x) >= c)
         IMPLIES f(a) - f(b) >= a * c - b * c

Postponing mvt_gen_ge_real.2T.

mvt_gen_ge_real.3T (TCC):   

  |-------
{1}   connected?[real]
[2]   FORALL (f: [real -> real], c: real, a, b: real):
        (derivable?[real](f) AND
          a >= b AND FORALL (x: real): deriv[real](f)(x) >= c)
         IMPLIES f(a) - f(b) >= c * (a - b)

No change on: (SKIP)
mvt_gen_ge_real.3T (TCC):   

  |-------
{1}   connected?[real]
[2]   FORALL (f: [real -> real], c: real, a, b: real):
        (derivable?[real](f) AND
          a >= b AND FORALL (x: real): deriv[real](f)(x) >= c)
         IMPLIES f(a) - f(b) >= c * (a - b)

Postponing mvt_gen_ge_real.3T.

mvt_gen_ge_real.2T :  

{-1}  connected?[real]
  |-------
[1]   not_one_element?[real]
[2]   FORALL (f: [real -> real], c: real, a, b: real):
        (derivable?[real](f) AND
          a >= b AND FORALL (x: real): deriv[real](f)(x) >= c)
         IMPLIES f(a) - f(b) >= a * c - b * c

***Warning: mvt_gen_ge_real.2T has fewer subproofs (0) than subgoals (1)
No change on: (SKIP)
mvt_gen_ge_real.2T :  

{-1}  connected?[real]
  |-------
[1]   not_one_element?[real]
[2]   FORALL (f: [real -> real], c: real, a, b: real):
        (derivable?[real](f) AND
          a >= b AND FORALL (x: real): deriv[real](f)(x) >= c)
         IMPLIES f(a) - f(b) >= a * c - b * c

Postponing mvt_gen_ge_real.2T.

mvt_gen_ge_real.3T (TCC):   

  |-------
{1}   connected?[real]
[2]   FORALL (f: [real -> real], c: real, a, b: real):
        (derivable?[real](f) AND
          a >= b AND FORALL (x: real): deriv[real](f)(x) >= c)
         IMPLIES f(a) - f(b) >= c * (a - b)

No change on: (SKIP)
mvt_gen_ge_real.3T (TCC):   

  |-------
{1}   connected?[real]
[2]   FORALL (f: [real -> real], c: real, a, b: real):
        (derivable?[real](f) AND
          a >= b AND FORALL (x: real): deriv[real](f)(x) >= c)
         IMPLIES f(a) - f(b) >= c * (a - b)

Postponing mvt_gen_ge_real.3T.

mvt_gen_ge_real.2T :  

{-1}  connected?[real]
  |-------
[1]   not_one_element?[real]
[2]   FORALL (f: [real -> real], c: real, a, b: real):
        (derivable?[real](f) AND
          a >= b AND FORALL (x: real): deriv[real](f)(x) >= c)
         IMPLIES f(a) - f(b) >= a * c - b * c

Postponing mvt_gen_ge_real.2T.

mvt_gen_ge_real.3T (TCC):   

  |-------
{1}   connected?[real]
[2]   FORALL (f: [real -> real], c: real, a, b: real):
        (derivable?[real](f) AND
          a >= b AND FORALL (x: real): deriv[real](f)(x) >= c)
         IMPLIES f(a) - f(b) >= c * (a - b)

Postponing mvt_gen_ge_real.3T.

mvt_gen_ge_real.2T :  

{-1}  connected?[real]
  |-------
[1]   not_one_element?[real]
[2]   FORALL (f: [real -> real], c: real, a, b: real):
        (derivable?[real](f) AND
          a >= b AND FORALL (x: real): deriv[real](f)(x) >= c)
         IMPLIES f(a) - f(b) >= a * c - b * c


Run time  = 0.09 secs.
Real time = 0.09 secs.

active_corner_certificate.mvt_gen_ge_real unproved in 0.09 real, 0.09 cpu seconds
Rerunning proof of active_corner_certificate.mvt_gen_le_real
Installing rewrite rule sets.singleton_rew (all instances)
Installing rewrite rule analysis@lim_of_functions.adherence_fullset (all instances)
Installing rewrite rule reals@sq.sq_abs_neg
Installing rewrite rule reals@sq.sq_abs
Installing rewrite rule reals@sq.sq_1
Installing rewrite rule reals@sq.sq_0
Installing rewrite rule reals@abs_lems.abs_0
Installing rewrite rule reals@abs_lems.abs_nat
Installing rewrite rule sets.member (all instances)
Installing rewrite rule list_props.member (all instances)
mvt_gen_le_real :  

  |-------
{1}   FORALL (f: [real -> real], c: real, a, b: real):
        (derivable?[real](f) AND
          a >= b AND FORALL (x: real): deriv[real](f)(x) <= c)
         IMPLIES f(a) - f(b) <= c * (a - b)

Rerunning step: (SPREAD (LEMMA "mean_value[real]")
                 ((THEN (SKEEP) (INST -1 "b" "a" "f") (ASSERT) (SKEEP)
                   (INST -6 "c!1") (EXPAND "deriv" -6) (ASSERT)
                   (MULT-BY -6 "a-b") (ASSERT))
                  (THEN (ASSERT) (LEMMA "connected_real") (PROPAX))))
Applying mean_value[real] 
this yields  3 subgoals: 
mvt_gen_le_real.1 :  

{-1}  FORALL (a, b: real, f: [real -> real]):
        derivable?(f) AND a < b IMPLIES
         EXISTS (c: real):
           a < c AND c < b AND deriv(f, c) * (b - a) = f(b) - f(a)
  |-------
[1]   FORALL (f: [real -> real], c: real, a, b: real):
        (derivable?[real](f) AND
          a >= b AND FORALL (x: real): deriv[real](f)(x) <= c)
         IMPLIES f(a) - f(b) <= c * (a - b)

Skolemizing and keeping names of the universal formula in (+ -),
this simplifies to: 
mvt_gen_le_real.1 :  

[-1]  FORALL (a, b: real, f: [real -> real]):
        derivable?(f) AND a < b IMPLIES
         EXISTS (c: real):
           a < c AND c < b AND deriv(f, c) * (b - a) = f(b) - f(a)
{-2}  derivable?[real](f)
{-3}  a >= b
{-4}  FORALL (x: real): deriv[real](f)(x) <= c
  |-------
{1}   f(a) - f(b) <= c * (a - b)

Instantiating the top quantifier in -1 with the terms: 
 b, a, f,
this simplifies to: 
mvt_gen_le_real.1 :  

{-1}  derivable?(f) AND b < a IMPLIES
       EXISTS (c: real):
         b < c AND c < a AND deriv(f, c) * (a - b) = f(a) - f(b)
[-2]  derivable?[real](f)
[-3]  a >= b
[-4]  FORALL (x: real): deriv[real](f)(x) <= c
  |-------
[1]   f(a) - f(b) <= c * (a - b)

Simplifying, rewriting, and recording with decision procedures,
this simplifies to: 
mvt_gen_le_real.1 :  

{-1}  EXISTS (c: real):
        b < c AND c < a AND deriv(f, c) * a - deriv(f, c) * b = f(a) - f(b)
[-2]  derivable?[real](f)
[-3]  a >= b
[-4]  FORALL (x: real): deriv[real](f)(x) <= c
  |-------
{1}   f(a) - f(b) <= a * c - b * c

Skolemizing and keeping names of the universal formula in (+ -),
this simplifies to: 
mvt_gen_le_real.1 :  

{-1}  b < c!1
{-2}  c!1 < a
{-3}  deriv(f, c!1) * a - deriv(f, c!1) * b = f(a) - f(b)
[-4]  derivable?[real](f)
[-5]  a >= b
[-6]  FORALL (x: real): deriv[real](f)(x) <= c
  |-------
[1]   f(a) - f(b) <= a * c - b * c

Instantiating the top quantifier in -6 with the terms: 
 c!1,
this simplifies to: 
mvt_gen_le_real.1 :  

[-1]  b < c!1
[-2]  c!1 < a
[-3]  deriv(f, c!1) * a - deriv(f, c!1) * b = f(a) - f(b)
[-4]  derivable?[real](f)
[-5]  a >= b
{-6}  deriv[real](f)(c!1) <= c
  |-------
[1]   f(a) - f(b) <= a * c - b * c

Expanding the definition of deriv,
this simplifies to: 
mvt_gen_le_real.1 :  

[-1]  b < c!1
[-2]  c!1 < a
[-3]  deriv(f, c!1) * a - deriv(f, c!1) * b = f(a) - f(b)
[-4]  derivable?[real](f)
[-5]  a >= b
{-6}  deriv[real](f, c!1) <= c
  |-------
[1]   f(a) - f(b) <= a * c - b * c

Simplifying, rewriting, and recording with decision procedures,
this simplifies to: 
mvt_gen_le_real.1 :  

[-1]  b < c!1
[-2]  c!1 < a
[-3]  deriv(f, c!1) * a - deriv(f, c!1) * b = f(a) - f(b)
[-4]  derivable?[real](f)
[-5]  a >= b
[-6]  deriv[real](f, c!1) <= c
  |-------
[1]   f(a) - f(b) <= a * c - b * c

Multiplying both sides of selected formulas by given term,
this simplifies to: 
mvt_gen_le_real.1 :  

{-1}  deriv[real](f, c!1) * (a - b) <= c * (a - b)
[-2]  b < c!1
[-3]  c!1 < a
[-4]  deriv(f, c!1) * a - deriv(f, c!1) * b = f(a) - f(b)
[-5]  derivable?[real](f)
[-6]  a >= b
  |-------
[1]   f(a) - f(b) <= a * c - b * c

Simplifying, rewriting, and recording with decision procedures,

This completes the proof of mvt_gen_le_real.1.

mvt_gen_le_real.2T (TCC):   

  |-------
{1}   not_one_element?[real]
[2]   FORALL (f: [real -> real], c: real, a, b: real):
        (derivable?[real](f) AND
          a >= b AND FORALL (x: real): deriv[real](f)(x) <= c)
         IMPLIES f(a) - f(b) <= c * (a - b)

Simplifying, rewriting, and recording with decision procedures,
this simplifies to: 
mvt_gen_le_real.2T :  

  |-------
[1]   not_one_element?[real]
{2}   FORALL (f: [real -> real], c: real, a, b: real):
        (derivable?[real](f) AND
          a >= b AND FORALL (x: real): deriv[real](f)(x) <= c)
         IMPLIES f(a) - f(b) <= a * c - b * c

Applying connected_real 
this simplifies to: 
mvt_gen_le_real.2T :  

{-1}  connected?[real]
  |-------
[1]   not_one_element?[real]
[2]   FORALL (f: [real -> real], c: real, a, b: real):
        (derivable?[real](f) AND
          a >= b AND FORALL (x: real): deriv[real](f)(x) <= c)
         IMPLIES f(a) - f(b) <= a * c - b * c

No change on: (PROPAX)
mvt_gen_le_real.2T :  

{-1}  connected?[real]
  |-------
[1]   not_one_element?[real]
[2]   FORALL (f: [real -> real], c: real, a, b: real):
        (derivable?[real](f) AND
          a >= b AND FORALL (x: real): deriv[real](f)(x) <= c)
         IMPLIES f(a) - f(b) <= a * c - b * c

Postponing mvt_gen_le_real.2T.

mvt_gen_le_real.3T (TCC):   

  |-------
{1}   connected?[real]
[2]   FORALL (f: [real -> real], c: real, a, b: real):
        (derivable?[real](f) AND
          a >= b AND FORALL (x: real): deriv[real](f)(x) <= c)
         IMPLIES f(a) - f(b) <= c * (a - b)

No change on: (SKIP)
mvt_gen_le_real.3T (TCC):   

  |-------
{1}   connected?[real]
[2]   FORALL (f: [real -> real], c: real, a, b: real):
        (derivable?[real](f) AND
          a >= b AND FORALL (x: real): deriv[real](f)(x) <= c)
         IMPLIES f(a) - f(b) <= c * (a - b)

Postponing mvt_gen_le_real.3T.

mvt_gen_le_real.2T :  

{-1}  connected?[real]
  |-------
[1]   not_one_element?[real]
[2]   FORALL (f: [real -> real], c: real, a, b: real):
        (derivable?[real](f) AND
          a >= b AND FORALL (x: real): deriv[real](f)(x) <= c)
         IMPLIES f(a) - f(b) <= a * c - b * c

***Warning: mvt_gen_le_real.2T has fewer subproofs (0) than subgoals (1)
No change on: (SKIP)
mvt_gen_le_real.2T :  

{-1}  connected?[real]
  |-------
[1]   not_one_element?[real]
[2]   FORALL (f: [real -> real], c: real, a, b: real):
        (derivable?[real](f) AND
          a >= b AND FORALL (x: real): deriv[real](f)(x) <= c)
         IMPLIES f(a) - f(b) <= a * c - b * c

Postponing mvt_gen_le_real.2T.

mvt_gen_le_real.3T (TCC):   

  |-------
{1}   connected?[real]
[2]   FORALL (f: [real -> real], c: real, a, b: real):
        (derivable?[real](f) AND
          a >= b AND FORALL (x: real): deriv[real](f)(x) <= c)
         IMPLIES f(a) - f(b) <= c * (a - b)

No change on: (SKIP)
mvt_gen_le_real.3T (TCC):   

  |-------
{1}   connected?[real]
[2]   FORALL (f: [real -> real], c: real, a, b: real):
        (derivable?[real](f) AND
          a >= b AND FORALL (x: real): deriv[real](f)(x) <= c)
         IMPLIES f(a) - f(b) <= c * (a - b)

Postponing mvt_gen_le_real.3T.

mvt_gen_le_real.2T :  

{-1}  connected?[real]
  |-------
[1]   not_one_element?[real]
[2]   FORALL (f: [real -> real], c: real, a, b: real):
        (derivable?[real](f) AND
          a >= b AND FORALL (x: real): deriv[real](f)(x) <= c)
         IMPLIES f(a) - f(b) <= a * c - b * c

Postponing mvt_gen_le_real.2T.

mvt_gen_le_real.3T (TCC):   

  |-------
{1}   connected?[real]
[2]   FORALL (f: [real -> real], c: real, a, b: real):
        (derivable?[real](f) AND
          a >= b AND FORALL (x: real): deriv[real](f)(x) <= c)
         IMPLIES f(a) - f(b) <= c * (a - b)

Postponing mvt_gen_le_real.3T.

mvt_gen_le_real.2T :  

{-1}  connected?[real]
  |-------
[1]   not_one_element?[real]
[2]   FORALL (f: [real -> real], c: real, a, b: real):
        (derivable?[real](f) AND
          a >= b AND FORALL (x: real): deriv[real](f)(x) <= c)
         IMPLIES f(a) - f(b) <= a * c - b * c


Run time  = 0.10 secs.
Real time = 0.10 secs.

active_corner_certificate.mvt_gen_le_real unproved in 0.10 real, 0.10 cpu seconds
Rerunning proof of active_corner_certificate.ge_real_case_0
Installing rewrite rule sets.singleton_rew (all instances)
Installing rewrite rule analysis@lim_of_functions.adherence_fullset (all instances)
Installing rewrite rule reals@sq.sq_abs_neg
Installing rewrite rule reals@sq.sq_abs
Installing rewrite rule reals@sq.sq_1
Installing rewrite rule reals@sq.sq_0
Installing rewrite rule reals@abs_lems.abs_0
Installing rewrite rule reals@abs_lems.abs_nat
Installing rewrite rule sets.member (all instances)
Installing rewrite rule list_props.member (all instances)
ge_real_case_0 :  

  |-------
{1}   FORALL (xo, yo: real, g: [real -> real]):
        LET f: [real -> real] = LAMBDA (x: real): g(x) IN
          derivable?[real](f) AND
           (FORALL (x: real): deriv[real](f)(x) >= 1) AND
            (EXISTS (x: real):
               ((-x + xo + 2 >= 0) AND
                 (-x + xo - 2 <= 0) AND
                  (yo - f(x) + 1 >= 0) AND (yo - f(x) - 1 <= 0))
                AND xo + 2 >= x AND xo + -2 <= x)
           IMPLIES
           ((yo - f(xo - 2) - 1 >= 0) AND (yo - f(xo + 2) + 1 <= 0)) OR
            ((yo - f(xo - 2) + 1 >= 0) AND (yo - f(xo + 2) - 1 <= 0)) OR
             ((yo - f(xo + 2) - 1 >= 0) AND (yo - f(xo - 2) + 1 <= 0)) OR
              ((yo - f(xo + 2) + 1 >= 0) AND (yo - f(xo - 2) - 1 <= 0))

Rerunning step: (THEN (SKEEP*) (SKOLETIN*) (FLATTEN) (SKEEP)
                 (LEMMA "mvt_gen_ge_real") (ASSERT)
                 (INST -1 "f" "1" "xo + 2" "x")
                 (SPREAD (SPLIT -1)
                  ((THEN (ASSERT) (LEMMA "mvt_gen_ge_real")
                    (INST -1 "f" "1" "x" "xo - 2")
                    (SPREAD (SPLIT -1) ((ASSERT) (PROPAX) (ASSERT) (PROPAX))))
                   (PROPAX) (ASSERT) (PROPAX))))
Iterating skeep in '*,
this simplifies to: 
ge_real_case_0 :  

  |-------
{1}   LET f: [real -> real] = LAMBDA (x: real): g(x) IN
        (derivable?[real](f) AND
          (FORALL (x: real): deriv[real](f)(x) >= 1) AND
           EXISTS (x: real):
             ((-x + xo + 2 >= 0) AND
               (-x + xo - 2 <= 0) AND
                (yo - f(x) + 1 >= 0) AND (yo - f(x) - 1 <= 0))
              AND xo + 2 >= x AND xo + -2 <= x)
         IMPLIES
         ((yo - f(xo - 2) - 1 >= 0) AND (yo - f(xo + 2) + 1 <= 0)) OR
          ((yo - f(xo - 2) + 1 >= 0) AND (yo - f(xo + 2) - 1 <= 0)) OR
           ((yo - f(xo + 2) - 1 >= 0) AND (yo - f(xo - 2) + 1 <= 0)) OR
            ((yo - f(xo + 2) + 1 >= 0) AND (yo - f(xo - 2) - 1 <= 0))

Naming let-in bindings in *,
this simplifies to: 
ge_real_case_0 :  

{-1}  (f) = (LAMBDA (x: real): g(x))
  |-------
{1}   (derivable?[real](f) AND
        (FORALL (x: real): deriv[real](f)(x) >= 1) AND
         EXISTS (x: real):
           ((-x + xo + 2 >= 0) AND
             (-x + xo - 2 <= 0) AND
              (yo - f(x) + 1 >= 0) AND (yo - f(x) - 1 <= 0))
            AND xo + 2 >= x AND xo + -2 <= x)
       IMPLIES
       ((yo - f(xo - 2) - 1 >= 0) AND (yo - f(xo + 2) + 1 <= 0)) OR
        ((yo - f(xo - 2) + 1 >= 0) AND (yo - f(xo + 2) - 1 <= 0)) OR
         ((yo - f(xo + 2) - 1 >= 0) AND (yo - f(xo - 2) + 1 <= 0)) OR
          ((yo - f(xo + 2) + 1 >= 0) AND (yo - f(xo - 2) - 1 <= 0))

Applying disjunctive simplification to flatten sequent,
this simplifies to: 
ge_real_case_0 :  

{-1}  derivable?[real](f)
{-2}  FORALL (x: real): deriv[real](f)(x) >= 1
{-3}  EXISTS (x: real):
        ((-x + xo + 2 >= 0) AND
          (-x + xo - 2 <= 0) AND
           (yo - f(x) + 1 >= 0) AND (yo - f(x) - 1 <= 0))
         AND xo + 2 >= x AND xo + -2 <= x
[-4]  (f) = (LAMBDA (x: real): g(x))
  |-------
{1}   ((yo - f(xo - 2) - 1 >= 0) AND (yo - f(xo + 2) + 1 <= 0))
{2}   ((yo - f(xo - 2) + 1 >= 0) AND (yo - f(xo + 2) - 1 <= 0))
{3}   ((yo - f(xo + 2) - 1 >= 0) AND (yo - f(xo - 2) + 1 <= 0))
{4}   ((yo - f(xo + 2) + 1 >= 0) AND (yo - f(xo - 2) - 1 <= 0))

Skolemizing and keeping names of the universal formula in (+ -),
this simplifies to: 
ge_real_case_0 :  

[-1]  derivable?[real](f)
[-2]  FORALL (x: real): deriv[real](f)(x) >= 1
{-3}  (-x + xo + 2 >= 0)
{-4}  (-x + xo - 2 <= 0)
{-5}  (yo - f(x) + 1 >= 0)
{-6}  (yo - f(x) - 1 <= 0)
{-7}  xo + 2 >= x
{-8}  xo + -2 <= x
[-9]  (f) = (LAMBDA (x: real): g(x))
  |-------
[1]   ((yo - f(xo - 2) - 1 >= 0) AND (yo - f(xo + 2) + 1 <= 0))
[2]   ((yo - f(xo - 2) + 1 >= 0) AND (yo - f(xo + 2) - 1 <= 0))
[3]   ((yo - f(xo + 2) - 1 >= 0) AND (yo - f(xo - 2) + 1 <= 0))
[4]   ((yo - f(xo + 2) + 1 >= 0) AND (yo - f(xo - 2) - 1 <= 0))

Applying mvt_gen_ge_real 
this simplifies to: 
ge_real_case_0 :  

{-1}  FORALL (f: [real -> real], c: real, a, b: real):
        (derivable?[real](f) AND
          a >= b AND FORALL (x: real): deriv[real](f)(x) >= c)
         IMPLIES f(a) - f(b) >= c * (a - b)
[-2]  derivable?[real](f)
[-3]  FORALL (x: real): deriv[real](f)(x) >= 1
[-4]  (-x + xo + 2 >= 0)
[-5]  (-x + xo - 2 <= 0)
[-6]  (yo - f(x) + 1 >= 0)
[-7]  (yo - f(x) - 1 <= 0)
[-8]  xo + 2 >= x
[-9]  xo + -2 <= x
[-10] (f) = (LAMBDA (x: real): g(x))
  |-------
[1]   ((yo - f(xo - 2) - 1 >= 0) AND (yo - f(xo + 2) + 1 <= 0))
[2]   ((yo - f(xo - 2) + 1 >= 0) AND (yo - f(xo + 2) - 1 <= 0))
[3]   ((yo - f(xo + 2) - 1 >= 0) AND (yo - f(xo - 2) + 1 <= 0))
[4]   ((yo - f(xo + 2) + 1 >= 0) AND (yo - f(xo - 2) - 1 <= 0))

Simplifying, rewriting, and recording with decision procedures,
this simplifies to: 
ge_real_case_0 :  

{-1}  FORALL (f: [real -> real], c: real, a, b: real):
        (derivable?[real](f) AND
          a >= b AND FORALL (x: real): deriv[real](f)(x) >= c)
         IMPLIES f(a) - f(b) >= a * c - b * c
[-2]  derivable?[real](f)
[-3]  FORALL (x: real): deriv[real](f)(x) >= 1
{-4}  (2 + -x + xo >= 0)
{-5}  (-x - 2 + xo <= 0)
{-6}  (1 - f(x) + yo >= 0)
{-7}  (-1 - f(x) + yo <= 0)
{-8}  2 + xo >= x
{-9}  xo - 2 <= x
[-10] (f) = (LAMBDA (x: real): g(x))
  |-------
{1}   ((-1 - f(xo - 2) + yo >= 0) AND (1 - f(2 + xo) + yo <= 0))
{2}   ((1 - f(xo - 2) + yo >= 0) AND (-1 - f(2 + xo) + yo <= 0))
{3}   ((-1 - f(2 + xo) + yo >= 0) AND (1 - f(xo - 2) + yo <= 0))
{4}   ((1 - f(2 + xo) + yo >= 0) AND (-1 - f(xo - 2) + yo <= 0))

Instantiating the top quantifier in -1 with the terms: 
 f, 1, xo + 2, x,
this simplifies to: 
ge_real_case_0 :  

{-1}  (derivable?[real](f) AND
        xo + 2 >= x AND FORALL (x: real): deriv[real](f)(x) >= 1)
       IMPLIES f(xo + 2) - f(x) >= (xo + 2) * 1 - x * 1
[-2]  derivable?[real](f)
[-3]  FORALL (x: real): deriv[real](f)(x) >= 1
[-4]  (2 + -x + xo >= 0)
[-5]  (-x - 2 + xo <= 0)
[-6]  (1 - f(x) + yo >= 0)
[-7]  (-1 - f(x) + yo <= 0)
[-8]  2 + xo >= x
[-9]  xo - 2 <= x
[-10] (f) = (LAMBDA (x: real): g(x))
  |-------
[1]   ((-1 - f(xo - 2) + yo >= 0) AND (1 - f(2 + xo) + yo <= 0))
[2]   ((1 - f(xo - 2) + yo >= 0) AND (-1 - f(2 + xo) + yo <= 0))
[3]   ((-1 - f(2 + xo) + yo >= 0) AND (1 - f(xo - 2) + yo <= 0))
[4]   ((1 - f(2 + xo) + yo >= 0) AND (-1 - f(xo - 2) + yo <= 0))

Splitting conjunctions,
this yields  4 subgoals: 
ge_real_case_0.1 :  

{-1}  f(xo + 2) - f(x) >= (xo + 2) * 1 - x * 1
[-2]  derivable?[real](f)
[-3]  FORALL (x: real): deriv[real](f)(x) >= 1
[-4]  (2 + -x + xo >= 0)
[-5]  (-x - 2 + xo <= 0)
[-6]  (1 - f(x) + yo >= 0)
[-7]  (-1 - f(x) + yo <= 0)
[-8]  2 + xo >= x
[-9]  xo - 2 <= x
[-10] (f) = (LAMBDA (x: real): g(x))
  |-------
[1]   ((-1 - f(xo - 2) + yo >= 0) AND (1 - f(2 + xo) + yo <= 0))
[2]   ((1 - f(xo - 2) + yo >= 0) AND (-1 - f(2 + xo) + yo <= 0))
[3]   ((-1 - f(2 + xo) + yo >= 0) AND (1 - f(xo - 2) + yo <= 0))
[4]   ((1 - f(2 + xo) + yo >= 0) AND (-1 - f(xo - 2) + yo <= 0))

Simplifying, rewriting, and recording with decision procedures,
this simplifies to: 
ge_real_case_0.1 :  

{-1}  f(2 + xo) - f(x) >= 2 - x + xo
[-2]  derivable?[real](f)
[-3]  FORALL (x: real): deriv[real](f)(x) >= 1
[-4]  (2 + -x + xo >= 0)
[-5]  (-x - 2 + xo <= 0)
[-6]  (1 - f(x) + yo >= 0)
[-7]  (-1 - f(x) + yo <= 0)
[-8]  2 + xo >= x
[-9]  xo - 2 <= x
[-10] (f) = (LAMBDA (x: real): g(x))
  |-------
[1]   ((-1 - f(xo - 2) + yo >= 0) AND (1 - f(2 + xo) + yo <= 0))
{2}   (1 - f(xo - 2) + yo >= 0)
{3}   (-1 - f(2 + xo) + yo >= 0)
{4}   (1 - f(2 + xo) + yo >= 0)

Applying mvt_gen_ge_real 
this simplifies to: 
ge_real_case_0.1 :  

{-1}  FORALL (f: [real -> real], c: real, a, b: real):
        (derivable?[real](f) AND
          a >= b AND FORALL (x: real): deriv[real](f)(x) >= c)
         IMPLIES f(a) - f(b) >= c * (a - b)
[-2]  f(2 + xo) - f(x) >= 2 - x + xo
[-3]  derivable?[real](f)
[-4]  FORALL (x: real): deriv[real](f)(x) >= 1
[-5]  (2 + -x + xo >= 0)
[-6]  (-x - 2 + xo <= 0)
[-7]  (1 - f(x) + yo >= 0)
[-8]  (-1 - f(x) + yo <= 0)
[-9]  2 + xo >= x
[-10] xo - 2 <= x
[-11] (f) = (LAMBDA (x: real): g(x))
  |-------
[1]   ((-1 - f(xo - 2) + yo >= 0) AND (1 - f(2 + xo) + yo <= 0))
[2]   (1 - f(xo - 2) + yo >= 0)
[3]   (-1 - f(2 + xo) + yo >= 0)
[4]   (1 - f(2 + xo) + yo >= 0)

Instantiating the top quantifier in -1 with the terms: 
 f, 1, x, xo - 2,
this simplifies to: 
ge_real_case_0.1 :  

{-1}  (derivable?[real](f) AND
        x >= xo - 2 AND FORALL (x: real): deriv[real](f)(x) >= 1)
       IMPLIES f(x) - f(xo - 2) >= 1 * (x - (xo - 2))
[-2]  f(2 + xo) - f(x) >= 2 - x + xo
[-3]  derivable?[real](f)
[-4]  FORALL (x: real): deriv[real](f)(x) >= 1
[-5]  (2 + -x + xo >= 0)
[-6]  (-x - 2 + xo <= 0)
[-7]  (1 - f(x) + yo >= 0)
[-8]  (-1 - f(x) + yo <= 0)
[-9]  2 + xo >= x
[-10] xo - 2 <= x
[-11] (f) = (LAMBDA (x: real): g(x))
  |-------
[1]   ((-1 - f(xo - 2) + yo >= 0) AND (1 - f(2 + xo) + yo <= 0))
[2]   (1 - f(xo - 2) + yo >= 0)
[3]   (-1 - f(2 + xo) + yo >= 0)
[4]   (1 - f(2 + xo) + yo >= 0)

Splitting conjunctions,
this yields  4 subgoals: 
ge_real_case_0.1.1 :  

{-1}  f(x) - f(xo - 2) >= 1 * (x - (xo - 2))
[-2]  f(2 + xo) - f(x) >= 2 - x + xo
[-3]  derivable?[real](f)
[-4]  FORALL (x: real): deriv[real](f)(x) >= 1
[-5]  (2 + -x + xo >= 0)
[-6]  (-x - 2 + xo <= 0)
[-7]  (1 - f(x) + yo >= 0)
[-8]  (-1 - f(x) + yo <= 0)
[-9]  2 + xo >= x
[-10] xo - 2 <= x
[-11] (f) = (LAMBDA (x: real): g(x))
  |-------
[1]   ((-1 - f(xo - 2) + yo >= 0) AND (1 - f(2 + xo) + yo <= 0))
[2]   (1 - f(xo - 2) + yo >= 0)
[3]   (-1 - f(2 + xo) + yo >= 0)
[4]   (1 - f(2 + xo) + yo >= 0)

Simplifying, rewriting, and recording with decision procedures,

This completes the proof of ge_real_case_0.1.1.

ge_real_case_0.1.2 :  

[-1]  f(2 + xo) - f(x) >= 2 - x + xo
[-2]  derivable?[real](f)
[-3]  FORALL (x: real): deriv[real](f)(x) >= 1
[-4]  (2 + -x + xo >= 0)
[-5]  (-x - 2 + xo <= 0)
[-6]  (1 - f(x) + yo >= 0)
[-7]  (-1 - f(x) + yo <= 0)
[-8]  2 + xo >= x
[-9]  xo - 2 <= x
[-10] (f) = (LAMBDA (x: real): g(x))
  |-------
{1}   derivable?[real](f)
[2]   ((-1 - f(xo - 2) + yo >= 0) AND (1 - f(2 + xo) + yo <= 0))
[3]   (1 - f(xo - 2) + yo >= 0)
[4]   (-1 - f(2 + xo) + yo >= 0)
[5]   (1 - f(2 + xo) + yo >= 0)

which is trivially true.

This completes the proof of ge_real_case_0.1.2.

ge_real_case_0.1.3 :  

[-1]  f(2 + xo) - f(x) >= 2 - x + xo
[-2]  derivable?[real](f)
[-3]  FORALL (x: real): deriv[real](f)(x) >= 1
[-4]  (2 + -x + xo >= 0)
[-5]  (-x - 2 + xo <= 0)
[-6]  (1 - f(x) + yo >= 0)
[-7]  (-1 - f(x) + yo <= 0)
[-8]  2 + xo >= x
[-9]  xo - 2 <= x
[-10] (f) = (LAMBDA (x: real): g(x))
  |-------
{1}   x >= xo - 2
[2]   ((-1 - f(xo - 2) + yo >= 0) AND (1 - f(2 + xo) + yo <= 0))
[3]   (1 - f(xo - 2) + yo >= 0)
[4]   (-1 - f(2 + xo) + yo >= 0)
[5]   (1 - f(2 + xo) + yo >= 0)

Simplifying, rewriting, and recording with decision procedures,

This completes the proof of ge_real_case_0.1.3.

ge_real_case_0.1.4 :  

[-1]  f(2 + xo) - f(x) >= 2 - x + xo
[-2]  derivable?[real](f)
[-3]  FORALL (x: real): deriv[real](f)(x) >= 1
[-4]  (2 + -x + xo >= 0)
[-5]  (-x - 2 + xo <= 0)
[-6]  (1 - f(x) + yo >= 0)
[-7]  (-1 - f(x) + yo <= 0)
[-8]  2 + xo >= x
[-9]  xo - 2 <= x
[-10] (f) = (LAMBDA (x: real): g(x))
  |-------
{1}   FORALL (x: real): deriv[real](f)(x) >= 1
[2]   ((-1 - f(xo - 2) + yo >= 0) AND (1 - f(2 + xo) + yo <= 0))
[3]   (1 - f(xo - 2) + yo >= 0)
[4]   (-1 - f(2 + xo) + yo >= 0)
[5]   (1 - f(2 + xo) + yo >= 0)

which is trivially true.

This completes the proof of ge_real_case_0.1.4.


This completes the proof of ge_real_case_0.1.

ge_real_case_0.2 :  

[-1]  derivable?[real](f)
[-2]  FORALL (x: real): deriv[real](f)(x) >= 1
[-3]  (2 + -x + xo >= 0)
[-4]  (-x - 2 + xo <= 0)
[-5]  (1 - f(x) + yo >= 0)
[-6]  (-1 - f(x) + yo <= 0)
[-7]  2 + xo >= x
[-8]  xo - 2 <= x
[-9]  (f) = (LAMBDA (x: real): g(x))
  |-------
{1}   derivable?[real](f)
[2]   ((-1 - f(xo - 2) + yo >= 0) AND (1 - f(2 + xo) + yo <= 0))
[3]   ((1 - f(xo - 2) + yo >= 0) AND (-1 - f(2 + xo) + yo <= 0))
[4]   ((-1 - f(2 + xo) + yo >= 0) AND (1 - f(xo - 2) + yo <= 0))
[5]   ((1 - f(2 + xo) + yo >= 0) AND (-1 - f(xo - 2) + yo <= 0))

which is trivially true.

This completes the proof of ge_real_case_0.2.

ge_real_case_0.3 :  

[-1]  derivable?[real](f)
[-2]  FORALL (x: real): deriv[real](f)(x) >= 1
[-3]  (2 + -x + xo >= 0)
[-4]  (-x - 2 + xo <= 0)
[-5]  (1 - f(x) + yo >= 0)
[-6]  (-1 - f(x) + yo <= 0)
[-7]  2 + xo >= x
[-8]  xo - 2 <= x
[-9]  (f) = (LAMBDA (x: real): g(x))
  |-------
{1}   xo + 2 >= x
[2]   ((-1 - f(xo - 2) + yo >= 0) AND (1 - f(2 + xo) + yo <= 0))
[3]   ((1 - f(xo - 2) + yo >= 0) AND (-1 - f(2 + xo) + yo <= 0))
[4]   ((-1 - f(2 + xo) + yo >= 0) AND (1 - f(xo - 2) + yo <= 0))
[5]   ((1 - f(2 + xo) + yo >= 0) AND (-1 - f(xo - 2) + yo <= 0))

Simplifying, rewriting, and recording with decision procedures,

This completes the proof of ge_real_case_0.3.

ge_real_case_0.4 :  

[-1]  derivable?[real](f)
[-2]  FORALL (x: real): deriv[real](f)(x) >= 1
[-3]  (2 + -x + xo >= 0)
[-4]  (-x - 2 + xo <= 0)
[-5]  (1 - f(x) + yo >= 0)
[-6]  (-1 - f(x) + yo <= 0)
[-7]  2 + xo >= x
[-8]  xo - 2 <= x
[-9]  (f) = (LAMBDA (x: real): g(x))
  |-------
{1}   FORALL (x: real): deriv[real](f)(x) >= 1
[2]   ((-1 - f(xo - 2) + yo >= 0) AND (1 - f(2 + xo) + yo <= 0))
[3]   ((1 - f(xo - 2) + yo >= 0) AND (-1 - f(2 + xo) + yo <= 0))
[4]   ((-1 - f(2 + xo) + yo >= 0) AND (1 - f(xo - 2) + yo <= 0))
[5]   ((1 - f(2 + xo) + yo >= 0) AND (-1 - f(xo - 2) + yo <= 0))

which is trivially true.

This completes the proof of ge_real_case_0.4.

Q.E.D.


Run time  = 0.46 secs.
Real time = 0.46 secs.

active_corner_certificate.ge_real_case_0 proved in 0.46 real, 0.46 cpu seconds
Rerunning proof of active_corner_certificate.full_domain_soundness_lemma
Installing rewrite rule sets.singleton_rew (all instances)
Installing rewrite rule analysis@lim_of_functions.adherence_fullset (all instances)
Installing rewrite rule reals@sq.sq_abs_neg
Installing rewrite rule reals@sq.sq_abs
Installing rewrite rule reals@sq.sq_1
Installing rewrite rule reals@sq.sq_0
Installing rewrite rule reals@abs_lems.abs_0
Installing rewrite rule reals@abs_lems.abs_nat
Installing rewrite rule sets.member (all instances)
Installing rewrite rule list_props.member (all instances)
full_domain_soundness_lemma :  

  |-------
{1}   FORALL (x, xo, yo: real):
        LET g: [real -> real] = LAMBDA (x: real): x IN
          (((-x + xo + 2 >= 0) AND
             (-x + xo - 2 <= 0) AND
              (yo - g(x) + 1 >= 0) AND (yo - g(x) - 1 <= 0))
            AND xo + 2 >= x AND xo + -2 <= x)
           IMPLIES
           ((yo - g(xo - 2) - 1 >= 0) AND (yo - g(xo + 2) + 1 <= 0)) OR
            ((yo - g(xo - 2) + 1 >= 0) AND (yo - g(xo + 2) - 1 <= 0)) OR
             ((yo - g(xo + 2) - 1 >= 0) AND (yo - g(xo - 2) + 1 <= 0)) OR
              ((yo - g(xo + 2) + 1 >= 0) AND (yo - g(xo - 2) - 1 <= 0))

Rerunning step: (THEN (SKEEP) (SKOLETIN*) (FLATTEN) (EXPAND "g_1")
                 (LEMMA "ge_real_case_0") (ASSERT))
Skolemizing and keeping names of the universal formula in (+ -),
this simplifies to: 
full_domain_soundness_lemma :  

  |-------
{1}   LET g: [real -> real] = LAMBDA (x: real): x IN
        (((-x + xo + 2 >= 0) AND
           (-x + xo - 2 <= 0) AND
            (yo - g(x) + 1 >= 0) AND (yo - g(x) - 1 <= 0))
          AND xo + 2 >= x AND xo + -2 <= x)
         IMPLIES
         ((yo - g(xo - 2) - 1 >= 0) AND (yo - g(xo + 2) + 1 <= 0)) OR
          ((yo - g(xo - 2) + 1 >= 0) AND (yo - g(xo + 2) - 1 <= 0)) OR
           ((yo - g(xo + 2) - 1 >= 0) AND (yo - g(xo - 2) + 1 <= 0)) OR
            ((yo - g(xo + 2) + 1 >= 0) AND (yo - g(xo - 2) - 1 <= 0))

Naming let-in bindings in *,
this simplifies to: 
full_domain_soundness_lemma :  

{-1}  (g_1) = (LAMBDA (x: real): x)
  |-------
{1}   (((-x + xo + 2 >= 0) AND
         (-x + xo - 2 <= 0) AND
          (yo - g_1(x) + 1 >= 0) AND (yo - g_1(x) - 1 <= 0))
        AND xo + 2 >= x AND xo + -2 <= x)
       IMPLIES
       ((yo - g_1(xo - 2) - 1 >= 0) AND (yo - g_1(xo + 2) + 1 <= 0)) OR
        ((yo - g_1(xo - 2) + 1 >= 0) AND (yo - g_1(xo + 2) - 1 <= 0)) OR
         ((yo - g_1(xo + 2) - 1 >= 0) AND (yo - g_1(xo - 2) + 1 <= 0)) OR
          ((yo - g_1(xo + 2) + 1 >= 0) AND (yo - g_1(xo - 2) - 1 <= 0))

Applying disjunctive simplification to flatten sequent,
this simplifies to: 
full_domain_soundness_lemma :  

{-1}  (-x + xo + 2 >= 0)
{-2}  (-x + xo - 2 <= 0)
{-3}  (yo - g_1(x) + 1 >= 0)
{-4}  (yo - g_1(x) - 1 <= 0)
{-5}  xo + 2 >= x
{-6}  xo + -2 <= x
[-7]  (g_1) = (LAMBDA (x: real): x)
  |-------
{1}   ((yo - g_1(xo - 2) - 1 >= 0) AND (yo - g_1(xo + 2) + 1 <= 0))
{2}   ((yo - g_1(xo - 2) + 1 >= 0) AND (yo - g_1(xo + 2) - 1 <= 0))
{3}   ((yo - g_1(xo + 2) - 1 >= 0) AND (yo - g_1(xo - 2) + 1 <= 0))
{4}   ((yo - g_1(xo + 2) + 1 >= 0) AND (yo - g_1(xo - 2) - 1 <= 0))

Expanding the definition of g_1,
this simplifies to: 
full_domain_soundness_lemma :  

[-1]  (-x + xo + 2 >= 0)
[-2]  (-x + xo - 2 <= 0)
{-3}  (1 - x + yo >= 0)
{-4}  (-1 - x + yo <= 0)
[-5]  xo + 2 >= x
[-6]  xo + -2 <= x
{-7}  (LAMBDA (x: real) -> real: x) = (LAMBDA (x: real): x)
  |-------
{1}   ((1 - xo + yo >= 0) AND (-1 - xo + yo <= 0))
{2}   ((3 - xo + yo >= 0) AND (-3 - xo + yo <= 0))
{3}   ((-3 - xo + yo >= 0) AND (3 - xo + yo <= 0))
{4}   ((-1 - xo + yo >= 0) AND (1 - xo + yo <= 0))

Applying ge_real_case_0 
this simplifies to: 
full_domain_soundness_lemma :  

{-1}  FORALL (xo, yo: real, g: [real -> real]):
        LET f: [real -> real] = LAMBDA (x: real): g(x) IN
          derivable?[real](f) AND
           (FORALL (x: real): deriv[real](f)(x) >= 1) AND
            (EXISTS (x: real):
               ((-x + xo + 2 >= 0) AND
                 (-x + xo - 2 <= 0) AND
                  (yo - f(x) + 1 >= 0) AND (yo - f(x) - 1 <= 0))
                AND xo + 2 >= x AND xo + -2 <= x)
           IMPLIES
           ((yo - f(xo - 2) - 1 >= 0) AND (yo - f(xo + 2) + 1 <= 0)) OR
            ((yo - f(xo - 2) + 1 >= 0) AND (yo - f(xo + 2) - 1 <= 0)) OR
             ((yo - f(xo + 2) - 1 >= 0) AND (yo - f(xo - 2) + 1 <= 0)) OR
              ((yo - f(xo + 2) + 1 >= 0) AND (yo - f(xo - 2) - 1 <= 0))
[-2]  (-x + xo + 2 >= 0)
[-3]  (-x + xo - 2 <= 0)
[-4]  (1 - x + yo >= 0)
[-5]  (-1 - x + yo <= 0)
[-6]  xo + 2 >= x
[-7]  xo + -2 <= x
[-8]  (LAMBDA (x: real) -> real: x) = (LAMBDA (x: real): x)
  |-------
[1]   ((1 - xo + yo >= 0) AND (-1 - xo + yo <= 0))
[2]   ((3 - xo + yo >= 0) AND (-3 - xo + yo <= 0))
[3]   ((-3 - xo + yo >= 0) AND (3 - xo + yo <= 0))
[4]   ((-1 - xo + yo >= 0) AND (1 - xo + yo <= 0))

Simplifying, rewriting, and recording with decision procedures,
Q.E.D.


Run time  = 0.37 secs.
Real time = 0.37 secs.

active_corner_certificate.full_domain_soundness_lemma proved in 0.37 real, 0.37 cpu seconds


 Proof summary for theory active_corner_certificate
    left_open_connected...................proved - complete   [SHOSTAK](0.00 s)
    left_open_noe.........................proved - complete   [SHOSTAK](0.00 s)
    left_open_dd..........................proved - incomplete [SHOSTAK](0.00 s)
    right_open_connected..................proved - complete   [SHOSTAK](0.00 s)
    right_open_noe........................proved - complete   [SHOSTAK](0.00 s)
    right_open_dd.........................proved - incomplete [SHOSTAK](0.00 s)
    ci_noe................................proved - complete   [SHOSTAK](0.00 s)
    ci_connected..........................proved - complete   [SHOSTAK](0.00 s)
    ci_dd.................................proved - incomplete [SHOSTAK](0.00 s)
    mvt_gen_ge_TCC1.......................proved - incomplete [SHOSTAK](0.00 s)
    mvt_gen_ge_TCC2.......................proved - incomplete [SHOSTAK](0.00 s)
    mvt_gen_ge............................proved - incomplete [SHOSTAK](0.00 s)
    mvt_gen_le............................proved - incomplete [SHOSTAK](0.00 s)
    mvt_gen_ge_lo_TCC1....................proved - incomplete [SHOSTAK](0.00 s)
    mvt_gen_ge_lo_TCC2....................proved - incomplete [SHOSTAK](0.00 s)
    mvt_gen_ge_lo.........................proved - incomplete [SHOSTAK](0.00 s)
    mvt_gen_le_lo.........................proved - incomplete [SHOSTAK](0.00 s)
    mvt_gen_ge_ro_TCC1....................proved - incomplete [SHOSTAK](0.00 s)
    mvt_gen_ge_ro_TCC2....................proved - incomplete [SHOSTAK](0.00 s)
    mvt_gen_ge_ro.........................proved - incomplete [SHOSTAK](0.00 s)
    mvt_gen_le_ro.........................proved - incomplete [SHOSTAK](0.00 s)
    mvt_gen_ge_ci_TCC1....................proved - incomplete [SHOSTAK](0.00 s)
    mvt_gen_ge_ci_TCC2....................proved - incomplete [SHOSTAK](0.00 s)
    mvt_gen_ge_ci.........................proved - incomplete [SHOSTAK](0.00 s)
    mvt_gen_le_ci.........................proved - incomplete [SHOSTAK](0.00 s)
    mvt_gen_ge_real_TCC1..................unfinished          [SHOSTAK](0.00 s)
    mvt_gen_ge_real_TCC2..................unfinished          [SHOSTAK](0.00 s)
    mvt_gen_ge_real.......................unfinished          [SHOSTAK](0.00 s)
    mvt_gen_le_real.......................unfinished          [SHOSTAK](0.00 s)
    ge_real_case_0........................proved - incomplete [SHOSTAK](0.00 s)
    full_domain_soundness_lemma...........proved - incomplete [SHOSTAK](0.00 s)
    Theory totals: 31 formulas, 31 attempted, 27 succeeded (0.00 s)

Grand Totals: 31 proofs, 31 attempted, 27 succeeded (0.00 s)
*** Warning: Missed 4 formulas.

Context file /Users/sdane/Desktop/automatic-safety-proofs/.pvscontext written
